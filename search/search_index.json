{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Digital Image Processing Helper","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This project provides tools for solving Digital Image Processing (DIP) problems, aimed at helping me and my colleagues practice and understand core concepts in DIP.</p>"},{"location":"#installation","title":"Installation","text":"<ol> <li> <p>Clone the Repository Bash<pre><code>git clone &lt;repository_url&gt;\n</code></pre></p> </li> <li> <p>Navigate to the Project Directory Bash<pre><code>cd DIP_solver\n</code></pre></p> </li> <li>Optionally if you will contribute make virtual environment Bash<pre><code>python -m venv .venv\n</code></pre></li> <li> <p>Activate the virtual environment Bash<pre><code>.\\.venv\\Scripts\\activate\n</code></pre></p> </li> <li> <p>Install requirements Bash<pre><code>pip install -r requirements.txt\n</code></pre></p> </li> <li> <p>Install the Package</p> </li> <li> <p>if you will contribute install the package in your environment in editable mode:    Bash<pre><code>pip install -e .\n</code></pre></p> </li> <li> <p>install the package and dependencies in your environment:    Bash<pre><code>pip install .\n</code></pre></p> </li> </ol>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Note: Using this project in IDLE or an interactive Python environment is recommended.</p> <ol> <li> <p>Import the Package    Start by importing the package:    Python<pre><code>from DIP.helper import make_random\n</code></pre></p> </li> <li> <p>Create a Random Matrix    You can generate a random matrix with the function <code>make_random(width: int = 3, height: int = 3, bit_depth: int = 8) -&gt; Matrix</code>.    Python<pre><code>width = 3\nheight = 3\nbit_depth = 8\nimg1 = make_random(width, height, bit_depth)\n</code></pre></p> </li> <li> <p>Choose a Kernel    Import a predefined kernel from the <code>Kernels</code> class:    Python<pre><code>from DIP.neighborhood_operations import Kernals\nkernel1 = Kernals.smoothing_filter\n</code></pre></p> </li> <li> <p>Display Matrices    Display one or more matrices using <code>display_matrices(list_of_matrices: List[Matrix], text: Optional[List[str]] = None, coordinates: bool = False)</code>:    Python<pre><code>display_matrices([img1, kernel1])\n</code></pre>    Sample output:    Text Only<pre><code>Matrix 1:\n[ 125 208 136 ]\n[ 130   1 240 ]\n[  93 207 170 ]\n\nMatrix 2:\n[ 0.111 0.111 0.111 ]\n[ 0.111 0.111 0.111 ]\n[ 0.111 0.111 0.111 ]\n</code></pre></p> </li> </ol>"},{"location":"#documentation","title":"Documentation","text":"<p>For full documentation, see docs.</p>"},{"location":"#the-story","title":"The Story","text":"<p>The project started because I wanted to understand the implementation of some algorithms and operations for a college course on Digital Image Processing. At first, I built it in NumPy\u2014faster, and I just wanted to learn the concepts. But then I thought, why not make it pure Python? This way, there are no external libraries needed, and I could share the code with my classmates so they could use it to solve any problem they wanted.</p> <p>Then the idea grew: why not make a TUI (Text-based User Interface) and quiz app that sticks to this DIY principle? I decided to build it entirely myself to deepen my understanding and give my classmates a useful, accessible tool.</p>"},{"location":"#what-i-learned","title":"What I Learned","text":"<ul> <li>Writing clear and helpful documentation</li> <li>Using Pydoc and focusing on self-explanatory code</li> <li>Creating guides on using code effectively</li> <li>Gaining deeper knowledge of Python</li> <li>Using mkdocs to auto-generate documentaion with docstring</li> <li>using github actions to auto build the documentaion on new releases</li> </ul>"},{"location":"#whats-next","title":"What's Next","text":"<ul> <li>Reimplement the project using NumPy and OOP principles</li> <li>make a text base user interface (TUI)</li> </ul>"},{"location":"cv/","title":"DIP.cv","text":""},{"location":"cv/#DIP.cv.calculate_glcm","title":"<code>calculate_glcm(matrix, distance, theta, normalize=False)</code>","text":"<p>Calculate the Symmetric Gray-Level Co-occurrence Matrix (GLCM) for a given grayscale matrix.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>2D grayscale matrix </p> required <code>`distance`</code> <code>int</code> <p>Distance between pixels to consider</p> required <code>`theta`</code> <code>Literal[0, 45, 90, 135]</code> <p>Angle in degrees for pixel pair direction</p> required <code>`normalize`</code> <code>bool</code> <p>Whether to normalize the GLCM. Defaults to False.</p> required <p>Returns:</p> Type Description <code>Union[List[List[int]], List[List[float]]]</code> <p>Union[List[List[int]], List[List[float]]]: Symmetric GLCM matrix (either integer or float)</p> Source code in <code>DIP/cv.py</code> Python<pre><code>def calculate_glcm(\n    matrix: Matrix, \n    distance: int, \n    theta: Literal[0, 45, 90, 135], \n    normalize: bool = False\n) -&gt; Union[List[List[int]], List[List[float]]]:\n    \"\"\"\n    Calculate the Symmetric Gray-Level Co-occurrence Matrix (GLCM) for a given grayscale matrix.\n\n    Parameters:\n        `matrix` (Matrix): 2D grayscale matrix \n        `distance` (int): Distance between pixels to consider\n        `theta` (Literal[0, 45, 90, 135]): Angle in degrees for pixel pair direction\n        `normalize` (bool, optional): Whether to normalize the GLCM. Defaults to False.\n\n    Returns:\n        Union[List[List[int]], List[List[float]]]: Symmetric GLCM matrix (either integer or float)\n    \"\"\"\n    # Find the maximum gray level in the matrix to determine GLCM size\n    max_gray_level = max(max(row) for row in matrix)\n    glcm_size = max_gray_level + 1\n\n    # Initialize GLCM matrix with zeros\n    glcm = [[0 for _ in range(glcm_size)] for _ in range(glcm_size)]\n\n    # Define offset calculations for each theta, scaled by distance\n    angle_offsets = {\n        0: (distance, 0),     # 0 degrees: horizontal\n        45: (distance, -distance),    # 45 degrees: diagonal up-right\n        90: (0, distance),    # 90 degrees: vertical\n        135: (distance, distance)   # 135 degrees: diagonal down-right\n    }\n\n    # Get the offset based on the specified theta\n    dx, dy = angle_offsets[theta]\n\n    # Iterate through the matrix to count co-occurrences\n    height = len(matrix)\n    width = len(matrix[0])\n\n    for y in range(height):\n        for x in range(width):\n            # Check if the offset pixel is within the matrix bounds\n            new_x = x + dx\n            new_y = y + dy\n\n            if 0 &lt;= new_x &lt; width and 0 &lt;= new_y &lt; height:\n                # Get current pixel and offset pixel values\n                current_pixel = matrix[y][x]\n                offset_pixel = matrix[new_y][new_x]\n\n                # Symmetric GLCM: increment both symmetric positions\n                if current_pixel != offset_pixel:\n                    # For different gray levels, increment both symmetric positions\n                    glcm[current_pixel][offset_pixel] += 1\n                    glcm[offset_pixel][current_pixel] += 1\n                else:\n                    # For same gray level (diagonal), multiply by 2\n                    glcm[current_pixel][offset_pixel] += 2\n\n    # Normalize if requested\n    if normalize:\n        # Calculate total sum for normalization\n        total_sum = sum(sum(row) for row in glcm)\n\n        # Create a new normalized GLCM\n        normalized_glcm = [\n            [round(count / total_sum,3) for count in row] \n            for row in glcm\n        ]\n\n        return normalized_glcm\n\n    return glcm\n</code></pre>"},{"location":"helper/","title":"DIP.helper","text":""},{"location":"helper/#DIP.helper.bit_depth_from_mat","title":"<code>bit_depth_from_mat(matrix)</code>","text":"<p>Calculates bit depth required to represent values in given matrix.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>Input data as a list of lists.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Bit depth calculated using logarithm base two.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; bit_depth_from_mat([[12,120],[15,80]])  \n7\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def bit_depth_from_mat(matrix: Matrix)-&gt;int:\n    \"\"\"\n    Calculates bit depth required to represent values in given matrix.\n\n    Parameters:\n        `matrix` (Matrix): Input data as a list of lists.\n\n    Returns:\n        int: Bit depth calculated using logarithm base two.\n\n    Examples:\n        &gt;&gt;&gt; bit_depth_from_mat([[12,120],[15,80]])  \n        7\n    \"\"\"\n    return m.ceil(m.log2(mat_max(matrix) + 1))\n</code></pre>"},{"location":"helper/#DIP.helper.clip","title":"<code>clip(x, min_value, max_value)</code>","text":"<p>Clips an integer value between min_value and max_value.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The integer value to clip.</p> required <code>min_value</code> <code>int</code> <p>The minimum allowed value.</p> required <code>max_value</code> <code>int</code> <p>The maximum allowed value.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The clipped value.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; clip(10,5 ,15)\n10\n&gt;&gt;&gt; clip(4 ,5 ,15)\n5\n&gt;&gt;&gt; clip(20 ,5 ,15)\n15\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def clip(x:int,min_value:int, max_value:int)-&gt;int:\n    \"\"\"\n    Clips an integer value between min_value and max_value.\n\n    Parameters:\n        x (int): The integer value to clip.\n        min_value (int): The minimum allowed value.\n        max_value (int): The maximum allowed value.\n\n    Returns:\n        int: The clipped value.\n\n    Examples:\n        &gt;&gt;&gt; clip(10,5 ,15)\n        10\n        &gt;&gt;&gt; clip(4 ,5 ,15)\n        5\n        &gt;&gt;&gt; clip(20 ,5 ,15)\n        15\n    \"\"\"\n    return min(max(x, min_value), max_value)\n</code></pre>"},{"location":"helper/#DIP.helper.display_matrices","title":"<code>display_matrices(list_of_matrices, text=None, coordinates=False)</code>","text":"<p>Display a list of matrices with optional coordinate labels. Each matrix is displayed with elements right-aligned for better readability.</p> <p>Parameters:</p> Name Type Description Default <code>`list_of_matrices`</code> <code>List[Matrix]</code> <p>A list of matrices to be displayed.</p> required <code>`text`</code> <code>(List[str], Optional)</code> <p>Optional text labels for each matrix.</p> required <code>`coordinates`</code> <code>bool</code> <p>If True display row and column numbers. Defaults to False.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length of text doesn't match the number of matrices</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; list_of_matrices = [\n...     [[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n...     [[10, 20, 30], [40, 50, 60], [70, 80, 90]]\n... ]\n&gt;&gt;&gt; display_matrices(list_of_matrices, coordinates=True)\nMatrix 1:\n    0 1 2\n0 [ 1 2 3 ]\n1 [ 4 5 6 ]\n2 [ 7 8 9 ]\n</code></pre> <p>Matrix 2:     0  1  2 0 [ 10 20 30 ] 1 [ 40 50 60 ] 2 [ 70 80 90 ]</p> Source code in <code>DIP/helper.py</code> Python<pre><code>def display_matrices(list_of_matrices: List[Matrix], text: Optional[List[str]] = None, coordinates: bool = False) -&gt; None:\n    \"\"\"\n    Display a list of matrices with optional coordinate labels.\n    Each matrix is displayed with elements right-aligned for better readability.\n\n    Parameters:\n        `list_of_matrices` (List[Matrix]): A list of matrices to be displayed.\n        `text` (List[str], Optional): Optional text labels for each matrix.\n        `coordinates` (bool): If True display row and column numbers. Defaults to False.\n\n    Raises:\n        ValueError: If the length of text doesn't match the number of matrices\n\n    Examples:\n        &gt;&gt;&gt; list_of_matrices = [\n        ...     [[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n        ...     [[10, 20, 30], [40, 50, 60], [70, 80, 90]]\n        ... ]\n        &gt;&gt;&gt; display_matrices(list_of_matrices, coordinates=True)\n        Matrix 1:\n            0 1 2\n        0 [ 1 2 3 ]\n        1 [ 4 5 6 ]\n        2 [ 7 8 9 ]\n\n        Matrix 2:\n            0  1  2\n        0 [ 10 20 30 ]\n        1 [ 40 50 60 ]\n        2 [ 70 80 90 ]\n    \"\"\"\n    # Input validation\n    if not list_of_matrices:\n        return\n\n    # Handle text labels\n    if text is None:\n        if len(list_of_matrices) == 1:\n            labels = [\"\"]  # Single matrix: no label\n        else:\n            labels = [f\"Matrix {i + 1}:\" for i in range(len(list_of_matrices))]  # Multiple matrices: numbered\n    else:\n        if len(text) != len(list_of_matrices):\n            raise ValueError(\"The length of list_of_matrices and text must be the same\")\n        labels = text\n\n    # Process each matrix\n    for matrix, label in zip(list_of_matrices, labels):\n        # Print the matrix label if it's not empty\n        if label:\n            print(label)\n\n        # Calculate the maximum length of any element in the matrix for uniform column width\n        max_length = max(len(str(item)) for row in matrix for item in row)\n\n        # Print column numbers as headers if coordinates is True\n        if coordinates:\n            print(\"    \", end=\"\")  # Initial spacing for alignment\n            for col_num in range(len(matrix[0])):\n                print(str(col_num).rjust(max_length), end=\" \")  # Right-align each column number\n            print()  # Newline after headers\n\n        # Print each row of the matrix with appropriate spacing and brackets\n        for idx, row in enumerate(matrix):\n            # Print row number if coordinates is True\n            if coordinates:\n                print(f\"{idx}\", end=\" \")\n\n            # Format and print the row\n            formatted_row = \" \".join(\n                str(val).rjust(max_length) \n                for val in row\n            )\n            print(f\"[ {formatted_row} ]\")\n        # Print an empty line to separate matrices\n        print()\n</code></pre>"},{"location":"helper/#DIP.helper.filter_by_kernel","title":"<code>filter_by_kernel(window, kernel, equal_to=1)</code>","text":"<p>Filters values from a window matrix based on a kernel matrix.</p> <p>Parameters:</p> Name Type Description Default <code>`window`</code> <code>Matrix</code> <p>The input window matrix.</p> required <code>`kernel`</code> <code>Matrix</code> <p>The kernel matrix used for filtering.</p> required <code>`equal_to`</code> <code>int</code> <p>The value to filter by. Defaults to 1.</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: A list of values from the window that correspond to the kernel's specified value.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat = [[1, 2], [3, 4]] \n&gt;&gt;&gt; ker = [[0, 1], [1, 0]]\n&gt;&gt;&gt; filter_by_kernel(mat, ker)\n[2, 3]\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def filter_by_kernel(window: Matrix, kernel: Matrix, equal_to:int = 1) -&gt; List[int]:\n    \"\"\"\n    Filters values from a window matrix based on a kernel matrix.\n\n    Parameters:\n        `window` (Matrix): The input window matrix.\n        `kernel` (Matrix): The kernel matrix used for filtering.\n        `equal_to` (int): The value to filter by. Defaults to 1.\n\n    Returns:\n        List[int]: A list of values from the window that correspond to the kernel's specified value.\n\n    Examples:\n        &gt;&gt;&gt; mat = [[1, 2], [3, 4]] \n        &gt;&gt;&gt; ker = [[0, 1], [1, 0]]\n        &gt;&gt;&gt; filter_by_kernel(mat, ker)\n        [2, 3]\n    \"\"\"\n    return [value for value, k in zip(flatten_matrix(window), flatten_matrix(kernel)) if k == equal_to]\n</code></pre>"},{"location":"helper/#DIP.helper.flatten_matrix","title":"<code>flatten_matrix(matrix)</code>","text":"<p>Flattens a 2D matrix into a 1D list.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>A 2D list of integers.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>A 1D list containing all elements from the input matrix.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; flatten_matrix([[1, 2], [3, 4]])\n[1, 2, 3, 4]\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def flatten_matrix(matrix: Matrix)-&gt;Matrix:\n    \"\"\"\n    Flattens a 2D matrix into a 1D list.\n\n    Parameters:\n        `matrix` (Matrix): A 2D list of integers.\n\n    Returns:\n        Matrix: A 1D list containing all elements from the input matrix.\n\n    Examples:\n        &gt;&gt;&gt; flatten_matrix([[1, 2], [3, 4]])\n        [1, 2, 3, 4]\n    \"\"\"\n    return [item for row in matrix for item in row]\n</code></pre>"},{"location":"helper/#DIP.helper.get_center","title":"<code>get_center(width=3, height=3, return_matrix=False)</code>","text":"<p>Get the center coordinate of a matrix of the specified shape or display it.</p> <p>Parameters:</p> Name Type Description Default <code>`width`</code> <code>int</code> <p>The number of columns in the matrix. Defaults to 3.</p> required <code>`height`</code> <code>int</code> <p>The number of rows in the matrix. Defaults to 3.</p> required <code>`return_matrix`</code> <code>bool</code> <p>If True returns a marked center coordinate in a visual format. Defaults to False.</p> required <p>Returns:</p> Type Description <code>Union[Matrix, Tuple[int, int]]</code> <p>If <code>return_matrix</code> is True returns a visual representation with \"X\" at center.</p> <code>Union[Matrix, Tuple[int, int]]</code> <p>If False returns (x,y) indices of the center coordinate.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; get_center(5, 5)\n(2, 2)\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; matrix = get_center(5, 5, return_matrix=True)\n&gt;&gt;&gt; display_matrices([matrix], coordinates=True)\n    0 1 2 3 4\n0 [ * * * * * ]\n1 [ * * * * * ]\n2 [ * * X * * ]\n3 [ * * * * * ]\n4 [ * * * * * ]\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def get_center(width: int = 3, height: int = 3, return_matrix: bool = False) -&gt; Union[Matrix, Tuple[int, int]]:\n    \"\"\"\n    Get the center coordinate of a matrix of the specified shape or display it.\n\n    Parameters:\n        `width` (int): The number of columns in the matrix. Defaults to 3.\n        `height` (int): The number of rows in the matrix. Defaults to 3.\n        `return_matrix` (bool): If True returns a marked center coordinate in a visual format. Defaults to False.\n\n    Returns:\n        If `return_matrix` is True returns a visual representation with \"X\" at center.\n        If False returns (x,y) indices of the center coordinate.\n\n    Examples:\n        &gt;&gt;&gt; get_center(5, 5)\n        (2, 2)\n\n        &gt;&gt;&gt; matrix = get_center(5, 5, return_matrix=True)\n        &gt;&gt;&gt; display_matrices([matrix], coordinates=True)\n            0 1 2 3 4\n        0 [ * * * * * ]\n        1 [ * * * * * ]\n        2 [ * * X * * ]\n        3 [ * * * * * ]\n        4 [ * * * * * ]\n    \"\"\"\n    x,y = height//2,width//2\n\n    if return_matrix:\n        return [[\"*\" if row != x or col != y else \"X\" for col in range(width)] for row in range(height)]\n    else:\n        return x,y\n</code></pre>"},{"location":"helper/#DIP.helper.get_pixel","title":"<code>get_pixel(matrix, index)</code>","text":"<p>Retrieve the value of a specific pixel in a matrix.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The input matrix.</p> required <code>`index`</code> <code>Tuple[int, int]</code> <p>The coordinates of the pixel to retrieve.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The value at the specified pixel location.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; matrix = [[1, 2, 3],\n...           [4, 5, 6],\n...           [7, 8, 9]]\n&gt;&gt;&gt; get_pixel(matrix, (1, 2))\n6\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def get_pixel(matrix: Matrix, index: Tuple[int, int]) -&gt; int:\n    \"\"\"\n    Retrieve the value of a specific pixel in a matrix.\n\n    Parameters:\n        `matrix` (Matrix): The input matrix.\n        `index` (Tuple[int,int]): The coordinates of the pixel to retrieve.\n\n    Returns:\n        int: The value at the specified pixel location.\n\n    Examples:\n        &gt;&gt;&gt; matrix = [[1, 2, 3],\n        ...           [4, 5, 6],\n        ...           [7, 8, 9]]\n        &gt;&gt;&gt; get_pixel(matrix, (1, 2))\n        6\n    \"\"\"\n    return matrix[index[0]][index[1]]\n</code></pre>"},{"location":"helper/#DIP.helper.intersection","title":"<code>intersection(matrix1, matrix2)</code>","text":"<p>Computes the pixel-wise intersection of two grayscale or binary images by taking the minimum value of corresponding pixels in each matrix.</p> <p>For binary images, this operation is equivalent to a logical AND, where  only overlapping regions with value 1 in both images will retain a value of 1.  For grayscale images, it selects the darker intensity for each pixel.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix1`</code> <code>Matrix</code> <p>First input matrix.</p> required <code>`matrix2`</code> <code>Matrix</code> <p>Second input matrix, with the same dimensions as matrix1.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>A new matrix containing minimum values from both matrices.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; m1 = [[1, 0], [1, 1]]\n&gt;&gt;&gt; m2 = [[1, 1], [0, 1]]\n&gt;&gt;&gt; intersection(m1, m2)\n[[1, 0], [0, 1]]\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def intersection(matrix1: Matrix, matrix2: Matrix) -&gt; Matrix:\n    \"\"\"\n    Computes the pixel-wise intersection of two grayscale or binary images by\n    taking the minimum value of corresponding pixels in each matrix.\n\n    For binary images, this operation is equivalent to a logical AND, where \n    only overlapping regions with value 1 in both images will retain a value of 1. \n    For grayscale images, it selects the darker intensity for each pixel.\n\n    Parameters:\n        `matrix1` (Matrix): First input matrix.\n        `matrix2` (Matrix): Second input matrix, with the same dimensions as matrix1.\n\n    Returns:\n        Matrix: A new matrix containing minimum values from both matrices.\n\n    Examples:\n        &gt;&gt;&gt; m1 = [[1, 0], [1, 1]]\n        &gt;&gt;&gt; m2 = [[1, 1], [0, 1]]\n        &gt;&gt;&gt; intersection(m1, m2)\n        [[1, 0], [0, 1]]\n    \"\"\"\n    result = [[min(matrix1[i][j], matrix2[i][j]) for j in range(len(matrix1[0]))] for i in range(len(matrix1))]\n    return result\n</code></pre>"},{"location":"helper/#DIP.helper.make_random","title":"<code>make_random(width=3, height=3, bit_depth=8)</code>","text":"<p>Create a random matrix with specified dimensions and bit depth.</p> <p>Parameters:</p> Name Type Description Default <code>`width`</code> <code>int</code> <p>The number of columns in the matrix. Defaults to 3.</p> required <code>`height`</code> <code>int</code> <p>The number of rows in the matrix. Defaults to 3.</p> required <code>`bit_depth`</code> <code>int</code> <p>The bit depth for the random values. Defaults to 8.</p> required <p>Returns:</p> Type Description <code>Matrix</code> <p><code>Matrix</code>: A matrix of the specified dimensions filled with random integers based on the bit depth.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; make_random(2, 2)\n[[23, 45], [12, 67]] # Output will vary\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def make_random(width: int = 3, height: int = 3, bit_depth: int = 8) -&gt; Matrix:\n    \"\"\"\n    Create a random matrix with specified dimensions and bit depth.\n\n    Parameters:\n        `width` (int): The number of columns in the matrix. Defaults to 3.\n        `height` (int): The number of rows in the matrix. Defaults to 3.\n        `bit_depth` (int): The bit depth for the random values. Defaults to 8.\n\n    Returns:\n        `Matrix`: A matrix of the specified dimensions filled with random integers based on the bit depth.\n\n    Examples:\n        &gt;&gt;&gt; make_random(2, 2)\n        [[23, 45], [12, 67]] # Output will vary\n    \"\"\"\n\n    max_value = 2 ** bit_depth\n    matrix = [[randint(0, max_value - 1) for _ in range(width)] for _ in range(height)]\n    return matrix\n</code></pre>"},{"location":"helper/#DIP.helper.make_realistic_matrix","title":"<code>make_realistic_matrix(width=9, height=9, bit_depth=1, elements_num=2, background_intensity_factor=0.2, foreground_intensity_factor=0.5, size_factor=0.4)</code>","text":"<p>Generate a realistic matrix with background and foreground objects.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the matrix</p> <code>9</code> <code>height</code> <code>int</code> <p>Height of the matrix</p> <code>9</code> <code>bit_depth</code> <code>int</code> <p>Bit depth for intensity values</p> <code>1</code> <code>elements_num</code> <code>int</code> <p>Number of foreground objects to generate</p> <code>2</code> <code>background_intensity_factor</code> <code>float</code> <p>Max background intensity as fraction of max value</p> <code>0.2</code> <code>foreground_intensity_factor</code> <code>float</code> <p>Min foreground intensity as fraction of max value</p> <code>0.5</code> <code>size_factor</code> <code>float</code> <p>Controls size of objects (0.0 to 1.0)</p> <code>0.4</code> <p>Returns:</p> Type Description <code>List[List[int]]</code> <p>Matrix with realistic intensity distribution</p> <p>Examples:     &gt;&gt;&gt; helper.make_realistic_matrix()     [ 0 0 0 0 0 0 0 0 0 ]     [ 0 0 0 0 0 0 0 0 0 ]     [ 0 0 0 0 0 0 0 0 0 ]     [ 0 0 0 0 0 1 1 1 0 ]     [ 0 0 0 0 0 1 1 1 0 ]     [ 0 0 0 0 0 1 1 1 0 ]     [ 0 0 0 1 1 1 1 1 0 ]     [ 0 0 0 1 1 1 1 0 0 ]     [ 0 0 0 1 1 1 1 0 0 ]</p> Source code in <code>DIP/helper.py</code> Python<pre><code>def make_realistic_matrix(\n    width: int = 9, \n    height: int = 9, \n    bit_depth: int = 1, \n    elements_num: int = 2,\n    background_intensity_factor: float = 0.2,\n    foreground_intensity_factor: float = 0.5,\n    size_factor: float = 0.4  # Controls the size of objects (0.0 to 1.0)\n) -&gt; List[List[int]]:\n    \"\"\"\n    Generate a realistic matrix with background and foreground objects.\n\n    Parameters:\n        width: Width of the matrix\n        height: Height of the matrix\n        bit_depth: Bit depth for intensity values\n        elements_num: Number of foreground objects to generate\n        background_intensity_factor: Max background intensity as fraction of max value\n        foreground_intensity_factor: Min foreground intensity as fraction of max value\n        size_factor: Controls size of objects (0.0 to 1.0)\n\n    Returns:\n        Matrix with realistic intensity distribution\n    Examples:\n        &gt;&gt;&gt; helper.make_realistic_matrix()\n        [ 0 0 0 0 0 0 0 0 0 ]\n        [ 0 0 0 0 0 0 0 0 0 ]\n        [ 0 0 0 0 0 0 0 0 0 ]\n        [ 0 0 0 0 0 1 1 1 0 ]\n        [ 0 0 0 0 0 1 1 1 0 ]\n        [ 0 0 0 0 0 1 1 1 0 ]\n        [ 0 0 0 1 1 1 1 1 0 ]\n        [ 0 0 0 1 1 1 1 0 0 ]\n        [ 0 0 0 1 1 1 1 0 0 ]\n    \"\"\"\n    from DIP.neighborhood_operations import Kernels, apply_filter\n\n    # Input validation\n    if width &lt; 1 or height &lt; 1:\n        raise ValueError(\"Width and height must be positive\")\n    if bit_depth &lt; 1 or bit_depth &gt; 32:\n        raise ValueError(\"Bit depth must be between 1 and 32\")\n    if elements_num &lt; 0:\n        raise ValueError(\"Number of elements must be non-negative\")\n    if not 0.0 &lt;= size_factor &lt;= 1.0:\n        raise ValueError(\"Size factor must be between 0.0 and 1.0\")\n\n    max_value = 2**bit_depth - 1\n\n    # Define intensity ranges\n    background_max = int(max_value * background_intensity_factor)\n    foreground_min = int(max_value * foreground_intensity_factor)\n\n    # Create background\n    matrix = [[randint(0, background_max) for _ in range(width + 2)] \n             for _ in range(height + 2)]\n\n    # Generate foreground objects\n    for _ in range(elements_num):\n        height, width = len(matrix), len(matrix[0])\n\n        # Calculate object size based on size_factor\n        obj_size = max(1, int(min(width, height) * size_factor))\n        obj_w = randint(int(obj_size * .75),obj_size)\n        obj_h = randint(int(obj_size * .75),obj_size)\n\n        # Generate random position ensuring object fits within matrix\n        obj_x = randint(0, height - obj_size)\n        obj_y = randint(0, width - obj_size)\n\n        # Add square object to matrix\n        for i in range(obj_x, obj_x + obj_h):\n            for j in range(obj_y, obj_y + obj_w):\n                if i &lt; height and j &lt; width:  # Boundary check\n                    if bit_depth == 1:\n                        matrix[i][j] = 1\n                    else:\n                        matrix[i][j] = randint(foreground_min, max_value)\n\n    matrix = apply_filter(matrix, Kernels.weighted_smoothing_filter, bit_depth=bit_depth)\n\n    return matrix\n</code></pre>"},{"location":"helper/#DIP.helper.mat_max","title":"<code>mat_max(matrix)</code>","text":"<p>Finds the maximum value in a given matrix.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Matrix</code> <p>A list of lists representing the input matrix.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The maximum value found.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat_max([[1 ,2 ,3],[4 ,5 ,6]])\n6\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def mat_max(matrix: Matrix) -&gt; int:\n    \"\"\"\n    Finds the maximum value in a given matrix.\n\n    Parameters:\n        matrix (Matrix): A list of lists representing the input matrix.\n\n    Returns:\n        int: The maximum value found.\n\n    Examples:\n        &gt;&gt;&gt; mat_max([[1 ,2 ,3],[4 ,5 ,6]])\n        6\n    \"\"\"\n\n    return max(max(row) for row in matrix)\n</code></pre>"},{"location":"helper/#DIP.helper.max_dimensions","title":"<code>max_dimensions(matrices)</code>","text":"<p>Calculates the maximum width and height from a list of 2D matrices.</p> <p>Parameters:</p> Name Type Description Default <code>matrices</code> <code>List[Matrix]]</code> <p>A list of 2D matrices represented as lists of lists.</p> required <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Tuple[int, int]: A tuple containing the maximum width and height:             (max_width, max_height), where             - max_width is the maximum number of columns in any matrix,             - max_height is the maximum number of rows in any matrix.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; matrices = [\n...     [[1, 0], [0, 1]],\n...     [[1, 1, 1], [0, 0, 0]],\n...     [[1]]\n... ]\n&gt;&gt;&gt; max_dimensions(matrices)\n(3, 2)\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def max_dimensions(matrices: List[Matrix]) -&gt; Tuple[int, int]:\n    \"\"\"\n    Calculates the maximum width and height from a list of 2D matrices.\n\n    Parameters:\n        matrices (List[Matrix]]): A list of 2D matrices represented as lists of lists.\n\n    Returns:\n        Tuple[int, int]: A tuple containing the maximum width and height:\n                        (max_width, max_height), where\n                        - max_width is the maximum number of columns in any matrix,\n                        - max_height is the maximum number of rows in any matrix.\n\n    Examples:\n        &gt;&gt;&gt; matrices = [\n        ...     [[1, 0], [0, 1]],\n        ...     [[1, 1, 1], [0, 0, 0]],\n        ...     [[1]]\n        ... ]\n        &gt;&gt;&gt; max_dimensions(matrices)\n        (3, 2)\n    \"\"\"\n    max_width = max(len(matrix[0]) for matrix in matrices if matrix)\n    max_height = max(len(matrix) for matrix in matrices if matrix)\n    return max_width, max_height\n</code></pre>"},{"location":"helper/#DIP.helper.normal_round","title":"<code>normal_round(float_to_round)</code>","text":"<p>Round a floating-point number to the nearest integer (not round half to even).</p> <p>Parameters:</p> Name Type Description Default <code>float_to_round</code> <code>float</code> <p>The number to round.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The rounded integer value.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; normal_round(2.3)\n2\n&gt;&gt;&gt; normal_round(2.5)\n3\n&gt;&gt;&gt; normal_round(2.8)\n3\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def normal_round(float_to_round: float) -&gt; int:\n    \"\"\"\n    Round a floating-point number to the nearest integer (not round half to even).\n\n    Parameters:\n        float_to_round (float): The number to round.\n\n    Returns:\n        int: The rounded integer value.\n\n    Examples:\n        &gt;&gt;&gt; normal_round(2.3)\n        2\n        &gt;&gt;&gt; normal_round(2.5)\n        3\n        &gt;&gt;&gt; normal_round(2.8)\n        3\n    \"\"\"\n\n    return int(float_to_round + 0.5)\n</code></pre>"},{"location":"helper/#DIP.helper.pixel_coordinates","title":"<code>pixel_coordinates(image, equal_to=1)</code>","text":"<p>Returns a set of coordinates where the pixel value equals the specified integer.</p> <p>Parameters:</p> Name Type Description Default <code>`image`</code> <code>Matrix</code> <p>The input image as a matrix.</p> required <code>`equal_to`</code> <code>int</code> <p>The pixel value to search for. Defaults to 1.</p> required <p>Returns:</p> Type Description <code>Set[Tuple[int, int]]</code> <p>Set[Tuple[int,int]]: A set of tuples representing the coordinates of matching pixels.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; pixel_coordinates([[0, 2], [1, 2], [1, 3]], equal_to=2)\n{(0, 1), (1, 1)}\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def pixel_coordinates(image: Matrix, equal_to: int = 1) -&gt; Set[Tuple[int,int]]:\n    \"\"\"\n    Returns a set of coordinates where the pixel value equals the specified integer.\n\n    Parameters:\n        `image` (Matrix): The input image as a matrix.\n        `equal_to` (int): The pixel value to search for. Defaults to 1.\n\n    Returns:\n        Set[Tuple[int,int]]: A set of tuples representing the coordinates of matching pixels.\n\n    Examples:\n        &gt;&gt;&gt; pixel_coordinates([[0, 2], [1, 2], [1, 3]], equal_to=2)\n        {(0, 1), (1, 1)}\n    \"\"\"\n    coordinates = set()\n    for r in range(len(image)):\n        for c in range(len(image[0])):\n            if image[r][c] == equal_to:\n                coordinates.add((r,c))\n    return coordinates\n</code></pre>"},{"location":"helper/#DIP.helper.resize","title":"<code>resize(matrix, size)</code>","text":"<p>This function resizes a given matrix <code>matrix</code> to the specified dimensions <code>size</code> using a custom algorithm. It spreads the original values from the source matrix into the resized matrix, placing empty cells in between the original values. It then fills in the empty cells based on the values of their neighboring cells.</p> Steps <ol> <li>Calculate the number of empty cells between the original values.</li> <li>Create a new resized matrix with the specified dimensions, initially filled with zeros.</li> <li>Spread the original values into the new matrix at appropriate intervals.</li> <li>Fill in the empty cells:<ul> <li>For empty row cells, take the average of the cells above and below.</li> <li>For empty column cells, take the average of the cells to the left and right.</li> <li>For empty diagonal cells, take the average of the four neighboring diagonal cells.</li> </ul> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The source matrix to be resized.</p> required <code>`size`</code> <code>Tuple[int, int]</code> <p>A tuple specifying the dimensions (<code>dst_rows</code>, <code>dst_cols</code>) of the resized matrix.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The resized matrix.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; matrix = [\n...     [1, 2, 3],\n...     [4, 5, 6],\n...     [7, 8, 9]\n... ]\n&gt;&gt;&gt; size = (6, 6)\n&gt;&gt;&gt; resized_matrix = resize(matrix, size)\n&gt;&gt;&gt; for row in resized_matrix:\n...     print(row)\n[1, 1, 2, 2, 3, 3]\n[2, 2, 3, 3, 4, 4]\n[4, 4, 5, 5, 6, 6]\n[5, 5, 6, 6, 7, 7]\n[7, 7, 8, 8, 9, 9]\n[8, 8, 9, 9, 10, 10]\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def resize(matrix: Matrix, size: Tuple[int, int]) -&gt; Matrix:\n    \"\"\"\n    This function resizes a given matrix `matrix` to the specified dimensions `size` using a custom algorithm. It spreads the original values from the source matrix into the resized matrix, placing empty cells in between the original values. It then fills in the empty cells based on the values of their neighboring cells.\n\n    Steps:\n        1. Calculate the number of empty cells between the original values.\n        2. Create a new resized matrix with the specified dimensions, initially filled with zeros.\n        3. Spread the original values into the new matrix at appropriate intervals.\n        4. Fill in the empty cells:\n            - For empty row cells, take the average of the cells above and below.\n            - For empty column cells, take the average of the cells to the left and right.\n            - For empty diagonal cells, take the average of the four neighboring diagonal cells.\n\n    Parameters:\n        `matrix` (Matrix): The source matrix to be resized.\n        `size` (Tuple[int, int]): A tuple specifying the dimensions (`dst_rows`, `dst_cols`) of the resized matrix.\n\n    Returns:\n        Matrix: The resized matrix.\n\n    Examples:\n        &gt;&gt;&gt; matrix = [\n        ...     [1, 2, 3],\n        ...     [4, 5, 6],\n        ...     [7, 8, 9]\n        ... ]\n        &gt;&gt;&gt; size = (6, 6)\n        &gt;&gt;&gt; resized_matrix = resize(matrix, size)\n        &gt;&gt;&gt; for row in resized_matrix:\n        ...     print(row)\n        [1, 1, 2, 2, 3, 3]\n        [2, 2, 3, 3, 4, 4]\n        [4, 4, 5, 5, 6, 6]\n        [5, 5, 6, 6, 7, 7]\n        [7, 7, 8, 8, 9, 9]\n        [8, 8, 9, 9, 10, 10]\n    \"\"\"\n    src_rows, src_cols = len(matrix), len(matrix[0])\n    dst_rows, dst_cols = size\n\n    # Calculate the number of empty cells between original values\n    row_spacing = (dst_rows - src_rows) // (src_rows - 1) if src_rows &gt; 1 else 0\n    col_spacing = (dst_cols - src_cols) // (src_cols - 1) if src_cols &gt; 1 else 0\n\n    # Create a new resized matrix with empty cells\n    resized_mat = [[0 for _ in range(dst_cols)] for _ in range(dst_rows)]\n\n    if row_spacing &lt; 0 or col_spacing &lt; 0:\n        return resized_mat\n\n    # Spread original values into the resized matrix with empty cells\n    for i in range(src_rows):\n        for j in range(src_cols):\n            resized_mat[(row_spacing + 1) * i][(col_spacing + 1) * j] = matrix[i][j]\n\n    # Fill in the empty cells\n    for i in range(dst_rows):\n        for j in range(dst_cols):\n            # For empty row cells\n            if i % (row_spacing + 1) != 0:\n                # Pixel value = round of average of right and left cells if not at last row, if at it copy last row\n                resized_mat[i][j] = normal_round((resized_mat[i-1][j] + resized_mat[min(i+1, dst_rows-1)][j]) / 2) if i != dst_rows - 1 else resized_mat[i-1][j]\n            # For empty column cells\n            elif j % (col_spacing + 1) != 0:\n                resized_mat[i][j] = normal_round((resized_mat[i][j-1] + resized_mat[i][min(j+1, dst_cols-1)]) / 2) if j != dst_cols - 1 else resized_mat[i][j-1]\n            # For empty diagonal cells\n            elif i % (row_spacing + 1) != 0 and j % (col_spacing + 1) != 0:\n                sum_neighbors = 0\n                count_neighbors = 0\n                if i &gt; 0 and j &gt; 0:\n                    sum_neighbors += resized_mat[i-1][j-1]\n                    count_neighbors += 1\n                if i &gt; 0 and j &lt; dst_cols - 1:\n                    sum_neighbors += resized_mat[i-1][j+1]\n                    count_neighbors += 1\n                if i &lt; dst_rows - 1 and j &gt; 0:\n                    sum_neighbors += resized_mat[i+1][j-1]\n                    count_neighbors += 1\n                if i &lt; dst_rows - 1 and j &lt; dst_cols - 1:\n                    sum_neighbors += resized_mat[i+1][j+1]\n                    count_neighbors += 1\n                resized_mat[i][j] = sum_neighbors // count_neighbors if count_neighbors &gt; 0 else 0\n\n    return resized_mat\n</code></pre>"},{"location":"helper/#DIP.helper.rotate_90","title":"<code>rotate_90(matrix, clockwise=True)</code>","text":"<p>Rotates a matrix 90 degrees clockwise (default) or counterclockwise.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The matrix to rotate.</p> required <code>`clockwise`</code> <code>bool</code> <p>If True (default), rotates clockwise; if False, rotates counterclockwise.</p> required <p>Returns:</p> Name Type Description <code>rotated</code> <code>Matrix</code> <p>The rotated matrix.</p> <p>Examples:     &gt;&gt;&gt; rotate_90([[10 ,20],     ...            [30 ,40]])     [[30 ,10]     ,[40 ,20]]</p> Source code in <code>DIP/helper.py</code> Python<pre><code>def rotate_90(matrix: Matrix, clockwise: bool = True) -&gt; Matrix:\n    \"\"\"\n    Rotates a matrix 90 degrees clockwise (default) or counterclockwise.\n\n    Parameters:\n        `matrix` (Matrix): The matrix to rotate.\n        `clockwise` (bool): If True (default), rotates clockwise; if False, rotates counterclockwise.\n\n    Returns:\n        rotated(Matrix): The rotated matrix.\n    Examples:\n        &gt;&gt;&gt; rotate_90([[10 ,20],\n        ...            [30 ,40]])\n        [[30 ,10]\n        ,[40 ,20]]\n    \"\"\"\n\n\n    if not matrix:\n        return []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Transpose the matrix\n    transposed = [[matrix[j][i] for j in range(rows)] for i in range(cols)]\n\n    if clockwise:\n        # Reverse each row to get the clockwise rotation\n        return [list(reversed(row)) for row in transposed]\n    else:\n        # Reverse the order of rows to get the counterclockwise rotation\n        return transposed[::-1]\n</code></pre>"},{"location":"helper/#DIP.helper.slice_matrix","title":"<code>slice_matrix(matrix, row_slice, col_slice)</code>","text":"<p>Slices a matrix based on specified row and column indices.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The input matrix to slice.</p> required <code>`row_slice`</code> <code>Tuple[int, int]</code> <p>A tuple indicating the start and end indices for rows.</p> required <code>`col_slice`</code> <code>Tuple[int, int]</code> <p>A tuple indicating the start and end indices for columns.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The sliced matrix.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; mat =  [[1, 2, 3],\n            [4, 5, 6]]\n&gt;&gt;&gt; slice_matrix(mat, (0, 2), (1, 3))\n[[2, 3], [5, 6]]\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def slice_matrix(matrix: Matrix, row_slice: Tuple[int, int], col_slice: Tuple[int, int]) -&gt; Matrix:\n    \"\"\"\n    Slices a matrix based on specified row and column indices.\n\n    Parameters:\n        `matrix` (Matrix): The input matrix to slice.\n        `row_slice` (Tuple[int, int]): A tuple indicating the start and end indices for rows.\n        `col_slice` (Tuple[int, int]): A tuple indicating the start and end indices for columns.\n\n    Returns:\n        Matrix: The sliced matrix.\n\n    Examples:\n        &gt;&gt;&gt; mat =  [[1, 2, 3],\n                    [4, 5, 6]]\n        &gt;&gt;&gt; slice_matrix(mat, (0, 2), (1, 3))\n        [[2, 3], [5, 6]]\n    \"\"\"\n    row_start, row_end = row_slice\n    col_start, col_end = col_slice\n    # Slicing beyond the length of the matrix does not throw an error\n    return [row[col_start:col_end] for row in matrix[row_start:row_end]]\n</code></pre>"},{"location":"helper/#DIP.helper.structuring_element_to_set","title":"<code>structuring_element_to_set(structuring_element, center_pos=None)</code>","text":"<p>Converts a structuring element into a set of relative coordinates based on its center position.</p> <p>Parameters:</p> Name Type Description Default <code>`structuring_element`</code> <code>Matrix</code> <p>The structuring element as a binary matrix.</p> required <code>`center_pos`</code> <code>Tuple[int, int] | None</code> <p>The center position. If None, the center is calculated.</p> required <p>Returns:</p> Type Description <code>Set[Tuple[int, int]]</code> <p>Set[Tuple[int,int]]: A set of relative coordinates where the structuring element is equal to 1.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; convert_structuring_element_to_set([[0, 1], [1, 0]])\n{(-1, 0), (0, -1)}\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def structuring_element_to_set(structuring_element: Matrix, center_pos: Tuple[int,int] = None) -&gt; Set[Tuple[int,int]]:\n    \"\"\"\n    Converts a structuring element into a set of relative coordinates based on its center position.\n\n    Parameters:\n        `structuring_element` (Matrix): The structuring element as a binary matrix.\n        `center_pos` (Tuple[int,int] | None): The center position. If None, the center is calculated.\n\n    Returns:\n        Set[Tuple[int,int]]: A set of relative coordinates where the structuring element is equal to 1.\n\n    Examples:\n        &gt;&gt;&gt; convert_structuring_element_to_set([[0, 1], [1, 0]])\n        {(-1, 0), (0, -1)}\n    \"\"\"\n    translation_set = set()\n\n    kernel_width = len(structuring_element[0])\n    kernel_height = len(structuring_element)\n\n    if center_pos == None:\n        center_pos = get_center(kernel_width,kernel_height)\n\n    # Convert the structuring element to a set of relative coordinates\n    for row in range(kernel_height):\n        for col in range(kernel_width):\n            if structuring_element[row][col] == 1:\n                translation_set.add((row - center_pos[0], col - center_pos[1]))\n    return translation_set\n</code></pre>"},{"location":"helper/#DIP.helper.trim","title":"<code>trim(matrix, trim_amount)</code>","text":"<p>Trims a specified number of rows and columns from the edges of a matrix.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Matrix</code> <p>The original 2D matrix to be trimmed.</p> required <code>trim_amount</code> <code>Tuple[int, int]</code> <p>A tuple (width, height) where:                             - width is the number of columns to remove from each side,                             - height is the number of rows to remove from each side.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The trimmed matrix with dimensions reduced by the specified width and height.             If the trim amount is greater than half the matrix dimensions, an empty matrix is returned.</p> Example <p>matrix = [ ...     [1, 2, 3, 4], ...     [5, 6, 7, 8], ...     [9, 10, 11, 12], ...     [13, 14, 15, 16] ... ] trim(matrix, (1, 1)) [[6, 7], [10, 11]]</p> Source code in <code>DIP/helper.py</code> Python<pre><code>def trim(matrix: Matrix, trim_amount: Tuple[int, int]) -&gt; Matrix:\n    \"\"\"\n    Trims a specified number of rows and columns from the edges of a matrix.\n\n    Parameters:\n        matrix (Matrix): The original 2D matrix to be trimmed.\n        trim_amount (Tuple[int, int]): A tuple (width, height) where:\n                                        - width is the number of columns to remove from each side,\n                                        - height is the number of rows to remove from each side.\n\n    Returns:\n        Matrix: The trimmed matrix with dimensions reduced by the specified width and height.\n                        If the trim amount is greater than half the matrix dimensions, an empty matrix is returned.\n\n    Example:\n        &gt;&gt;&gt; matrix = [\n        ...     [1, 2, 3, 4],\n        ...     [5, 6, 7, 8],\n        ...     [9, 10, 11, 12],\n        ...     [13, 14, 15, 16]\n        ... ]\n        &gt;&gt;&gt; trim(matrix, (1, 1))\n        [[6, 7], [10, 11]]\n    \"\"\"\n    trim_width, trim_height = trim_amount\n    num_rows = len(matrix)\n    num_cols = len(matrix[0]) if num_rows &gt; 0 else 0\n\n    # Ensure trimming does not exceed half the matrix size\n    if trim_width * 2 &gt;= num_cols or trim_height * 2 &gt;= num_rows:\n        return []  # Return empty matrix if trimming exceeds matrix dimensions\n\n    # Trim rows and columns from each side\n    trimmed_matrix = matrix[trim_height:num_rows - trim_height]\n    trimmed_matrix = [row[trim_width:num_cols - trim_width] for row in trimmed_matrix]\n\n    return trimmed_matrix\n</code></pre>"},{"location":"helper/#DIP.helper.union","title":"<code>union(matrix1, matrix2)</code>","text":"<p>Computes the pixel-wise union of two binary or grayscale images by taking the maximum value of corresponding pixels in each matrix.</p> <p>For binary images, this operation is equivalent to a logical OR, where  a pixel in the result is 1 if at least one of the corresponding pixels  in matrix1 or matrix2 is 1. For grayscale images, it selects the brighter  intensity for each pixel.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix1`</code> <code>Matrix</code> <p>The first image matrix.</p> required <code>`matrix2`</code> <code>Matrix</code> <p>The second image matrix, with the same dimensions as matrix1.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>A new matrix containing maximum values from both matrices.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; m1 = [[1, 0], [1, 1]]\n&gt;&gt;&gt; m2 = [[1, 1], [0, 1]]\n&gt;&gt;&gt; union(m1, m2)\n[[1, 1], [1, 1]]\n</code></pre> Source code in <code>DIP/helper.py</code> Python<pre><code>def union(matrix1: Matrix, matrix2: Matrix) -&gt; Matrix:\n    \"\"\"\n    Computes the pixel-wise union of two binary or grayscale images by\n    taking the maximum value of corresponding pixels in each matrix.\n\n    For binary images, this operation is equivalent to a logical OR, where \n    a pixel in the result is 1 if at least one of the corresponding pixels \n    in matrix1 or matrix2 is 1. For grayscale images, it selects the brighter \n    intensity for each pixel.\n\n    Parameters:\n        `matrix1` (Matrix): The first image matrix.\n        `matrix2` (Matrix): The second image matrix, with the same dimensions as matrix1.\n\n    Returns:\n        Matrix: A new matrix containing maximum values from both matrices.\n\n    Examples:\n        &gt;&gt;&gt; m1 = [[1, 0], [1, 1]]\n        &gt;&gt;&gt; m2 = [[1, 1], [0, 1]]\n        &gt;&gt;&gt; union(m1, m2)\n        [[1, 1], [1, 1]]\n    \"\"\"\n    result = [[max(matrix1[i][j], matrix2[i][j]) for j in range(len(matrix1[0]))] for i in range(len(matrix1))]\n    return result\n</code></pre>"},{"location":"morphology/","title":"DIP.morphology","text":""},{"location":"morphology/#DIP.morphology.closing","title":"<code>closing(matrix, se)</code>","text":"<p>Perform closing operation on a matrix using a given structuring element (se).</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The original binary matrix on which the closing operation is applied.</p> required <code>`se`</code> <code>Matrix</code> <p>The structuring element used for the closing operation.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The result of the closing operation on the matrix.</p> Description <p>The closing process consists of a dilation followed by an erosion using the same structuring element. This operation is useful for closing small holes in the foreground, bridging small gaps, and generally smoothing the outline of objects while keeping their sizes and shapes approximately the same.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; matrix = [[0,0,0,0,0,0], \n...          [0,1,1,1,1,0], \n...          [0,1,1,0,1,0],\n...          [0,1,1,0,1,0],\n...          [0,1,1,1,1,0]]\n&gt;&gt;&gt; se = [[1,1]\n...     ,[0,1]]\n&gt;&gt;&gt; result = closing(matrix,se)\n&gt;&gt;&gt; result\n[[0, 0, 0, 0, 0, 0]\n,[0, 1, 1, 1, 1, 0]\n,[0, 1, 1, 1, 1, 0]\n,[0, 1, 1, 1, 1, 0]\n,[0, 1, 1, 1, 1, 0]]\n</code></pre> Source code in <code>DIP/morphology.py</code> Python<pre><code>def closing(matrix: Matrix, se: Matrix) -&gt; Matrix:\n    \"\"\"\n    Perform closing operation on a matrix using a given structuring element (se).\n\n    Parameters:\n        `matrix` (Matrix): The original binary matrix on which the closing operation is applied.\n        `se` (Matrix): The structuring element used for the closing operation.\n\n    Returns:\n        Matrix: The result of the closing operation on the matrix.\n\n    Description:\n        The closing process consists of a dilation followed by an erosion using the same structuring element.\n        This operation is useful for closing small holes in the foreground, bridging small gaps, and generally smoothing the outline of objects\n        while keeping their sizes and shapes approximately the same.\n\n    Examples:\n        &gt;&gt;&gt; matrix = [[0,0,0,0,0,0], \n        ...          [0,1,1,1,1,0], \n        ...          [0,1,1,0,1,0],\n        ...          [0,1,1,0,1,0],\n        ...          [0,1,1,1,1,0]]\n        &gt;&gt;&gt; se = [[1,1]\n        ...     ,[0,1]]\n        &gt;&gt;&gt; result = closing(matrix,se)\n        &gt;&gt;&gt; result\n        [[0, 0, 0, 0, 0, 0]\n        ,[0, 1, 1, 1, 1, 0]\n        ,[0, 1, 1, 1, 1, 0]\n        ,[0, 1, 1, 1, 1, 0]\n        ,[0, 1, 1, 1, 1, 0]]\n    \"\"\"\n    dilated = dilation(matrix, se)\n    result = erosion(dilated, se)\n    return result\n</code></pre>"},{"location":"morphology/#DIP.morphology.convex_hull","title":"<code>convex_hull(matrix, list_of_structures, max_itiration=100)</code>","text":"<p>Computes the convex hull of a binary image using morphological operations. The function applies hit-or-miss transformations with specified structuring elements, iteratively refining the image until convergence or the maximum number of iterations is reached. The output is a binary matrix representing the convex hull.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Matrix</code> <p>A binary matrix (2D list) representing the input image where non-zero values               indicate foreground pixels.</p> required <code>list_of_structures</code> <code>List[Matrix]</code> <p>A list of structuring elements (binary matrices) used for                                   morphological operations. Each structuring element defines                                   the shape used in the hit-or-miss transformation.</p> required <code>max_itiration</code> <code>int</code> <p>The maximum number of iterations to perform. Default is 100.                              If convergence occurs before reaching this limit, the process will stop.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>A binary matrix representing the convex hull of the input image.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>matrix</code> is not a valid binary matrix or if <code>list_of_structures</code> is empty.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; input_matrix = [[0, 0, 1], [0, 1, 1], [0, 0, 0]]\n&gt;&gt;&gt; structures = [[[1]], [[1, 1]]]\n&gt;&gt;&gt; result = convex_hull(input_matrix, structures)\n</code></pre> Source code in <code>DIP/morphology.py</code> Python<pre><code>def convex_hull(matrix: Matrix, list_of_structures: List[Matrix], max_itiration:int = 100) -&gt; Matrix:\n    \"\"\"\n    Computes the convex hull of a binary image using morphological operations.\n    The function applies hit-or-miss transformations with specified structuring elements,\n    iteratively refining the image until convergence or the maximum number of iterations is reached.\n    The output is a binary matrix representing the convex hull.\n\n    Parameters:\n        matrix (Matrix): A binary matrix (2D list) representing the input image where non-zero values \n                         indicate foreground pixels.\n        list_of_structures (List[Matrix]): A list of structuring elements (binary matrices) used for \n                                             morphological operations. Each structuring element defines \n                                             the shape used in the hit-or-miss transformation.\n        max_itiration (int, optional): The maximum number of iterations to perform. Default is 100. \n                                        If convergence occurs before reaching this limit, the process will stop.\n\n    Returns:\n        Matrix: A binary matrix representing the convex hull of the input image.\n\n    Raises:\n        ValueError: If `matrix` is not a valid binary matrix or if `list_of_structures` is empty.\n\n    Examples:\n        &gt;&gt;&gt; input_matrix = [[0, 0, 1], [0, 1, 1], [0, 0, 0]]\n        &gt;&gt;&gt; structures = [[[1]], [[1, 1]]]\n        &gt;&gt;&gt; result = convex_hull(input_matrix, structures)\n    \"\"\"\n    from DIP.neighborhood_operations import pad\n    from DIP.helper import max_dimensions, trim\n    max_dimension = max_dimensions(list_of_structures)\n    matrix = pad(matrix, max_dimension)\n\n    result = [[0] * len(matrix[0]) for _ in range(len(matrix))]\n    for structure in list_of_structures:\n        X_prev = deepcopy(matrix)\n\n        for _ in range(max_itiration):\n            X_k = hit_or_miss(X_prev,structure)\n            X_k = union(X_k,X_prev)\n            # Check for convergence\n            if X_k == X_prev:\n                break\n\n            # Update X_prev for next iteration\n            X_prev = X_k\n\n        result = union(result, X_k)\n\n    return trim(result, (max_dimension[0]//2,max_dimension[1]//2))\n</code></pre>"},{"location":"morphology/#DIP.morphology.convex_hull_gen","title":"<code>convex_hull_gen(matrix, list_of_structures, max_itiration=10)</code>","text":"<p>Generates intermediate results while computing the convex hull of a binary image using morphological operations.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Matrix</code> <p>A binary matrix (2D list) representing the input image where non-zero values               indicate foreground pixels.</p> required <code>list_of_structures</code> <code>List[Matrix]</code> <p>A list of structuring elements (binary matrices) used for                                   morphological operations. Each structuring element defines                                   the shape used in the hit-or-miss transformation.</p> required <code>max_itiration</code> <code>int</code> <p>The maximum number of iterations to perform for each structuring                              element. Default is 10. The process stops if convergence occurs                              before reaching this limit.</p> <code>10</code> <p>Yields:</p> Type Description <code>tuple[int, int, Matrix]</code> <p>Tuple[int, int, Matrix]: A tuple containing: - The index of the structuring element being processed. - The current iteration number. - The current state of the binary matrix after applying transformations.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; input_matrix = [[0, 0, 1], [0, 1, 1], [0, 0, 0]]\n&gt;&gt;&gt; structures = [[[1]], [[1, 1]]]\n&gt;&gt;&gt; for index, iteration, result in convex_hull_gen(input_matrix, structures):\n...     print(f\"Structure {index}, Iteration {iteration}: {result}\")\n</code></pre> Source code in <code>DIP/morphology.py</code> Python<pre><code>def convex_hull_gen(matrix: Matrix, list_of_structures: List[Matrix], max_itiration:int = 10) -&gt; Generator[tuple[int, int, Matrix], None, None]:\n    \"\"\"\n    Generates intermediate results while computing the convex hull of a binary image using morphological operations.\n\n    Parameters:\n        matrix (Matrix): A binary matrix (2D list) representing the input image where non-zero values \n                         indicate foreground pixels.\n        list_of_structures (List[Matrix]): A list of structuring elements (binary matrices) used for \n                                             morphological operations. Each structuring element defines \n                                             the shape used in the hit-or-miss transformation.\n        max_itiration (int, optional): The maximum number of iterations to perform for each structuring \n                                        element. Default is 10. The process stops if convergence occurs \n                                        before reaching this limit.\n\n    Yields:\n        Tuple[int, int, Matrix]: A tuple containing:\n            - The index of the structuring element being processed.\n            - The current iteration number.\n            - The current state of the binary matrix after applying transformations.\n\n    Examples:\n        &gt;&gt;&gt; input_matrix = [[0, 0, 1], [0, 1, 1], [0, 0, 0]]\n        &gt;&gt;&gt; structures = [[[1]], [[1, 1]]]\n        &gt;&gt;&gt; for index, iteration, result in convex_hull_gen(input_matrix, structures):\n        ...     print(f\"Structure {index}, Iteration {iteration}: {result}\")\n    \"\"\"\n    from DIP.neighborhood_operations import pad\n    from DIP.helper import max_dimensions\n    max_dimension = max_dimensions(list_of_structures)\n    matrix = pad(matrix, max_dimension)\n\n    result = [[0] * len(matrix[0]) for _ in range(len(matrix))]\n    for i, structure in enumerate(list_of_structures,1):\n        X_prev = deepcopy(matrix)\n        # yielding x_0\n        yield i, 0, X_prev\n        for k in range(1, max_itiration):\n            X_k = hit_or_miss(X_prev,structure)\n            X_k = union(X_k,X_prev)\n            # Check for convergence\n            if X_k == X_prev:\n                break\n\n            # Update X_prev for next iteration\n            X_prev = X_k\n            yield i, k, X_k\n        result = union(result, X_k)\n        yield i, k, X_k\n    yield 0,0, result\n</code></pre>"},{"location":"morphology/#DIP.morphology.dilation","title":"<code>dilation(matrix, se)</code>","text":"<p>Perform set theoretic dilation of a binary matrix using a specified structuring element.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The original binary matrix where the dilation will be applied.</p> required <code>`se`</code> <code>Matrix</code> <p>The structuring element that defines how the dilation is performed.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The resulting binary matrix after dilation.</p> Description <p>This function expands the bright areas (1s) in the input matrix based on the structuring element. It first converts the structuring element into a set of relative positions. Then, for each bright pixel (1) in the input matrix, it adds the relative positions from the structuring element to create new bright pixels in the output matrix. This means that if a bright pixel is found, all positions defined by the structuring element around it will also become bright. The output matrix will have the same size as the input matrix.</p> <p>Examples:</p> <p>```python     &gt;&gt;&gt; matrix = [[0, 1, 0],     ...           [0, 0, 0],     ...           [1, 0, 0]]     &gt;&gt;&gt; se = [[1, 1],     ...       [1, 1]]     &gt;&gt;&gt; result = dilation(matrix, se)     &gt;&gt;&gt; result     [[1, 1, 0]     ,[1, 0, 0]     ,[1, 0, 0]]</p> Source code in <code>DIP/morphology.py</code> Python<pre><code>def dilation(matrix: Matrix, se: Matrix) -&gt; Matrix:\n    \"\"\"\n    Perform set theoretic dilation of a binary matrix using a specified structuring element.\n\n    Parameters:\n        `matrix` (Matrix): The original binary matrix where the dilation will be applied.\n        `se` (Matrix): The structuring element that defines how the dilation is performed.\n\n    Returns:\n        Matrix: The resulting binary matrix after dilation.\n\n    Description:\n        This function expands the bright areas (1s) in the input matrix based on the structuring element.\n        It first converts the structuring element into a set of relative positions.\n        Then, for each bright pixel (1) in the input matrix,\n        it adds the relative positions from the structuring element to create new bright pixels in the output matrix.\n        This means that if a bright pixel is found, all positions defined by the structuring element around it will also become bright.\n        The output matrix will have the same size as the input matrix.\n\n    Examples:\n    ```python\n        &gt;&gt;&gt; matrix = [[0, 1, 0],\n        ...           [0, 0, 0],\n        ...           [1, 0, 0]]\n        &gt;&gt;&gt; se = [[1, 1],\n        ...       [1, 1]]\n        &gt;&gt;&gt; result = dilation(matrix, se)\n        &gt;&gt;&gt; result\n        [[1, 1, 0]\n        ,[1, 0, 0]\n        ,[1, 0, 0]]\n    \"\"\"\n    # Convert structuring element to a set of relative coordinates\n    trans_set = structuring_element_to_set(se)\n    foreground_pixels = pixel_coordinates(matrix)\n\n    translated_set = set()\n    # translate every pixel by the each value in translation set\n    for pixel in foreground_pixels:\n        for translation in trans_set:\n            translated_set.add((pixel[0] + translation[0], pixel[1] + translation[1]))\n\n    matrix_width = len(matrix[0])\n    matrix_height = len(matrix)\n\n    dilated_matrix = [[0 for _ in range(matrix_width)] for _ in range(matrix_height)]\n\n    # Set the pixels in the result matrix to 1 where the dilated_pixels set contains coordinates\n    for pixel_pos in translated_set:\n        if 0 &lt;= pixel_pos[0] &lt; matrix_height and 0 &lt;= pixel_pos[1] &lt; matrix_width:\n            dilated_matrix[pixel_pos[0]][pixel_pos[1]] = 1\n\n    return dilated_matrix\n</code></pre>"},{"location":"morphology/#DIP.morphology.erosion","title":"<code>erosion(matrix, se)</code>","text":"<p>Perform erosion operation on a matrix using a given structuring element (se).</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The original binary matrix on which the erosion is applied.</p> required <code>`se`</code> <code>Matrix</code> <p>The structuring element used for the erosion operation.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The result of the erosion operation on the matrix.</p> Description <p>The erosion process involves sliding the <code>se</code> over the matrix and checking if all '1' pixels in the <code>se</code> align with '1' pixels in the matrix neighborhood. If they do, the center pixel of the neighborhood is set to '1' in the output matrix; otherwise, it is set to '0'. The output matrix has the same size as the input matrix.</p> <p>Examples:</p> <p>```python     &gt;&gt;&gt; matrix = [[1, 1, 0, 0],     ...           [1, 1, 0, 0],     ...           [0, 0, 1, 1],     ...           [0, 0, 1, 1]]     &gt;&gt;&gt; se = [[1, 1],     ...       [1, 1]]     &gt;&gt;&gt; result = erosion(matrix, se)     &gt;&gt;&gt; result     [[0, 0, 0, 0],     [0, 1, 0, 0],     [0, 0, 0, 0],     [0, 0, 0, 1]]</p> Source code in <code>DIP/morphology.py</code> Python<pre><code>def erosion(matrix: Matrix, se: Matrix) -&gt; Matrix:\n    \"\"\"\n    Perform erosion operation on a matrix using a given structuring element (se).\n\n    Parameters:\n        `matrix` (Matrix): The original binary matrix on which the erosion is applied.\n        `se` (Matrix): The structuring element used for the erosion operation.\n\n    Returns:\n        Matrix: The result of the erosion operation on the matrix.\n\n    Description:\n        The erosion process involves sliding the `se` over the matrix and checking if all '1' pixels in the `se` align with '1' pixels in the matrix neighborhood.\n        If they do, the center pixel of the neighborhood is set to '1' in the output matrix; otherwise, it is set to '0'.\n        The output matrix has the same size as the input matrix.\n\n    Examples:\n    ```python\n        &gt;&gt;&gt; matrix = [[1, 1, 0, 0],\n        ...           [1, 1, 0, 0],\n        ...           [0, 0, 1, 1],\n        ...           [0, 0, 1, 1]]\n        &gt;&gt;&gt; se = [[1, 1],\n        ...       [1, 1]]\n        &gt;&gt;&gt; result = erosion(matrix, se)\n        &gt;&gt;&gt; result\n        [[0, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 0, 0],\n        [0, 0, 0, 1]]\n    \"\"\"\n    height = len(matrix)\n    width = len(matrix[0])\n    # se = _rotate_180_clockwise(se)\n    se_h = len(se)\n    se_w = len(se[0])\n\n    # output will be same size as original in this case\n    output_mat = [[0 for _ in range(width)] for _ in range(height)]\n\n    # make bigger padded matrix \n    matrix = DN.pad(matrix,(se_w,se_h))\n\n    for i in range(height):\n        for j in range(width):\n            window = slice_matrix(matrix,(i,i+se_h), (j,j+se_w))\n            output_mat[i][j] = min(filter_by_kernel(window, se))\n\n    return output_mat\n</code></pre>"},{"location":"morphology/#DIP.morphology.external_extraction","title":"<code>external_extraction(matrix, se)</code>","text":"<p>Extracts external structures from a binary image by performing morphological dilation  followed by subtraction of the original image. This operation highlights outer  boundaries of objects in the image.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>Matrix Original binary image represented as a 2D list of 0s and 1s.</p> required <code>`se`</code> <code>Matrix</code> <p>Structuring element used for erosion, represented as a 2D list.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>Resulting binary image containing only the external boundaries.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; img = [[0, 0, 0, 0],\n...        [0, 1, 1, 0],\n...        [0, 1, 1, 0],\n...        [0, 0, 0, 0]]\n&gt;&gt;&gt; se = [[1, 1],\n...       [1, 1]]\n&gt;&gt;&gt; result = external_extraction(img, se)\n&gt;&gt;&gt; # Result will show the outer boundary surrounding the 2x2 square\n</code></pre> Source code in <code>DIP/morphology.py</code> Python<pre><code>def external_extraction(matrix: Matrix, se: Matrix) -&gt; Matrix:\n    \"\"\"\n    Extracts external structures from a binary image by performing morphological dilation \n    followed by subtraction of the original image. This operation highlights outer \n    boundaries of objects in the image.\n\n    Parameters:\n        `matrix` (Matrix): Matrix Original binary image represented as a 2D list of 0s and 1s.\n        `se` (Matrix): Structuring element used for erosion, represented as a 2D list.\n\n    Returns:\n        Matrix: Resulting binary image containing only the external boundaries.\n\n    Examples:\n        &gt;&gt;&gt; img = [[0, 0, 0, 0],\n        ...        [0, 1, 1, 0],\n        ...        [0, 1, 1, 0],\n        ...        [0, 0, 0, 0]]\n        &gt;&gt;&gt; se = [[1, 1],\n        ...       [1, 1]]\n        &gt;&gt;&gt; result = external_extraction(img, se)\n        &gt;&gt;&gt; # Result will show the outer boundary surrounding the 2x2 square\n    \"\"\"\n\n    dilated_matrix = dilation(matrix, se)\n\n    # Subtract the original image from the dilated image to get the external boundary\n    result_matrix = [[DO.clip(dilated_matrix[i][j] - matrix[i][j],0,1) for j in range(len(matrix[0]))] for i in range(len(matrix))]\n\n    return result_matrix\n</code></pre>"},{"location":"morphology/#DIP.morphology.hit_or_miss","title":"<code>hit_or_miss(matrix, se1, se2=None)</code>","text":"<p>Performs hit-or-miss transform (HMT) to detect specific patterns or templates in binary images using two complementary structuring elements. If only one structuring element is provided, it searches for exact matches while handling don't care elements ('x').</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>Binary image containing holes to be filled.</p> required <code>`se1`</code> <code>Matrix</code> <p>First structuring element that matches foreground pixels (1s).</p> required <code>`se2`</code> <code>Matrix</code> <p>Second structuring element that matches background pixels (0s).</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>Binary image where 1s indicate locations where the pattern was found.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; img = [[1, 1, 0],\n...        [1, 1, 0],\n...        [0, 0, 0]]\n&gt;&gt;&gt; se1 = [[1, 'x'],\n...        ['x', 1]]\n&gt;&gt;&gt; # Result will indicate the location of the pattern with 'x' as a don't care\n&gt;&gt;&gt; result = hit_or_miss(img, se1)\n</code></pre> Source code in <code>DIP/morphology.py</code> Python<pre><code>def hit_or_miss(matrix: Matrix, se1: Matrix, se2: Optional[Matrix] = None) -&gt; Matrix:\n    \"\"\"\n    Performs hit-or-miss transform (HMT) to detect specific patterns or templates\n    in binary images using two complementary structuring elements. If only one\n    structuring element is provided, it searches for exact matches while handling\n    don't care elements ('x').\n\n    Parameters:\n        `matrix` (Matrix): Binary image containing holes to be filled.\n        `se1` (Matrix): First structuring element that matches foreground pixels (1s).\n        `se2` (Matrix, optional): Second structuring element that matches background pixels (0s).\n\n    Returns:\n        Matrix: Binary image where 1s indicate locations where the pattern was found.\n\n    Examples:\n        &gt;&gt;&gt; img = [[1, 1, 0],\n        ...        [1, 1, 0],\n        ...        [0, 0, 0]]\n        &gt;&gt;&gt; se1 = [[1, 'x'],\n        ...        ['x', 1]]\n        &gt;&gt;&gt; # Result will indicate the location of the pattern with 'x' as a don't care\n        &gt;&gt;&gt; result = hit_or_miss(img, se1)\n    \"\"\"\n\n    if se2 is None:\n        # If only one structuring element is provided, look for exact matches\n        k_h, k_w = len(se1), len(se1[0])\n        result = [[0] * len(matrix[0]) for _ in range(len(matrix))]\n\n        # getting kernel center\n        x_offset, y_offset = k_h//2, k_w//2\n\n        for i in range(len(matrix) - k_h):\n            for j in range(len(matrix[0]) - k_w):\n                match_found = True\n                for r in range(k_h):\n                    for c in range(k_w):\n                        if se1[r][c] != 'x' and se1[r][c] != matrix[i + r][j + c]:\n                            match_found = False\n                            break\n                    if not match_found:\n                        break\n                if match_found:\n                    result[i + x_offset][j + y_offset] = 1\n        return result\n    else:\n        # If both structuring elements are provided, proceed with the original logic\n        complement_A = DO.complement(matrix, bit_depth=1)\n\n        A_erosion = erosion(matrix, se1)\n        A_c_dilation = erosion(complement_A, se2)\n        result = intersection(A_erosion, A_c_dilation)\n        return result\n</code></pre>"},{"location":"morphology/#DIP.morphology.hole_filling","title":"<code>hole_filling(matrix, se, x_0_indx, max_itiration=100)</code>","text":"<p>Fills holes in binary images using iterative morphological reconstruction based  on a marker point. A hole is defined as a background region completely  surrounded by foreground pixels.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>binary image containing holes to be filled.</p> required <code>`se`</code> <code>Matrix</code> <p>Structuring element.</p> required <code>`x_0_indx`</code> <code>Tuple[int, int]</code> <p>Starting point coordinates (row, col) inside the hole to be filled. Must be a background pixel (0) surrounded by foreground pixels (1).</p> required <code>`max_itiration`</code> <code>int</code> <p>Maximum number of iterations for the filling process. Default is 100. Prevents infinite loops in case of non-convergence.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>Binary image with the specified hole filled.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; img = [[1, 1, 1, 1],\n...        [1, 0, 0, 1],\n...        [1, 0, 0, 1],\n...        [1, 1, 1, 1]]\n&gt;&gt;&gt; se = [[0, 1, 0],\n...       [1, 1, 1],\n...       [0, 1, 0]]\n&gt;&gt;&gt; start_point = (1, 1)  # Coordinates inside the hole\n&gt;&gt;&gt; filled_img = hole_filling(img, se, start_point)\n&gt;&gt;&gt; # Result will fill the 2x2 hole with 1s\n</code></pre> Source code in <code>DIP/morphology.py</code> Python<pre><code>def hole_filling(matrix: Matrix, se: Matrix, x_0_indx: Tuple[int,int],max_itiration:int = 100) -&gt; Matrix:\n    \"\"\"\n    Fills holes in binary images using iterative morphological reconstruction based \n    on a marker point. A hole is defined as a background region completely \n    surrounded by foreground pixels.\n\n    Parameters:\n        `matrix` (Matrix): binary image containing holes to be filled.\n        `se` (Matrix): Structuring element.\n        `x_0_indx` (Tuple[int,int]): Starting point coordinates (row, col) inside the hole to be filled. Must be a background pixel (0) surrounded by foreground pixels (1).\n        `max_itiration` (int, optional): Maximum number of iterations for the filling process. Default is 100. Prevents infinite loops in case of non-convergence.\n\n    Returns:\n        Matrix: Binary image with the specified hole filled.\n\n    Examples:\n        &gt;&gt;&gt; img = [[1, 1, 1, 1],\n        ...        [1, 0, 0, 1],\n        ...        [1, 0, 0, 1],\n        ...        [1, 1, 1, 1]]\n        &gt;&gt;&gt; se = [[0, 1, 0],\n        ...       [1, 1, 1],\n        ...       [0, 1, 0]]\n        &gt;&gt;&gt; start_point = (1, 1)  # Coordinates inside the hole\n        &gt;&gt;&gt; filled_img = hole_filling(img, se, start_point)\n        &gt;&gt;&gt; # Result will fill the 2x2 hole with 1s\n    \"\"\"\n\n    X_prev = [[0] * len(matrix[0]) for _ in range(len(matrix))]\n    X_prev[x_0_indx[0]][x_0_indx[1]] = 1\n    complement_A = DO.complement(matrix,1)\n\n    for _ in range(max_itiration):\n        # Compute X_k = (X_{k-1} \u2295 B) \u2229 A^c\n        dilated_X_prev  = dilation(X_prev, se)\n        X_k = intersection(dilated_X_prev, complement_A)\n\n        # Check for convergence\n        if X_k == X_prev:\n            break\n\n        # Update X_prev for next iteration\n        X_prev = X_k\n\n    # Combine filled hole with original foreground\n    result = union(X_k, matrix)\n\n    return result\n</code></pre>"},{"location":"morphology/#DIP.morphology.hole_filling_X_gen","title":"<code>hole_filling_X_gen(matrix, se, x_0_indx, max_itiration=10)</code>","text":"<p>Generator version of hole filling algorithm that yields intermediate results  during the filling process. Useful for visualizing the progression of the  hole filling operation.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>binary image containing holes to be filled.</p> required <code>`se`</code> <code>Matrix</code> <p>Structuring element.</p> required <code>`x_0_indx`</code> <code>Tuple[int, int]</code> <p>Starting point coordinates (row, col) inside the hole to be filled. Must be a background pixel (0) surrounded by foreground pixels (1).</p> required <code>`max_itiration`</code> <code>int</code> <p>Maximum number of iterations for the filling process. Default is 10. Lower than regular hole_filling as this is for visualization.</p> required <p>Yields:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>Intermediate binary images showing the progressive filling of the hole. Each yield represents one step in the iterative process.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; img = [[1, 1, 1, 1],\n...        [1, 0, 0, 1],\n...        [1, 0, 0, 1],\n...        [1, 1, 1, 1]]\n&gt;&gt;&gt; se = [[0, 1, 0],\n...       [1, 1, 1],\n...       [0, 1, 0]]\n&gt;&gt;&gt; start_point = (1, 1)\n&gt;&gt;&gt; # get a list of 4 steps all filling\n&gt;&gt;&gt; xs = [*hole_filling_X_gen(img, se, start_point, max_itiration = 4)]\n&gt;&gt;&gt; plot_morphology(xs) # Custom function to show the matrix\n</code></pre> Source code in <code>DIP/morphology.py</code> Python<pre><code>def hole_filling_X_gen(matrix: Matrix, se: Matrix, x_0_indx: Tuple[int,int],max_itiration:int = 10) -&gt; Generator[Matrix,None,None]:\n    \"\"\"\n    Generator version of hole filling algorithm that yields intermediate results \n    during the filling process. Useful for visualizing the progression of the \n    hole filling operation.\n\n    Parameters:\n        `matrix` (Matrix): binary image containing holes to be filled.\n        `se` (Matrix): Structuring element.\n        `x_0_indx` (Tuple[int,int]): Starting point coordinates (row, col) inside the hole to be filled. Must be a background pixel (0) surrounded by foreground pixels (1).\n        `max_itiration` (int, optional): Maximum number of iterations for the filling process. Default is 10. Lower than regular hole_filling as this is for visualization.\n\n    Yields:\n        Matrix: Intermediate binary images showing the progressive filling of the hole. Each yield represents one step in the iterative process.\n\n    Examples:\n        &gt;&gt;&gt; img = [[1, 1, 1, 1],\n        ...        [1, 0, 0, 1],\n        ...        [1, 0, 0, 1],\n        ...        [1, 1, 1, 1]]\n        &gt;&gt;&gt; se = [[0, 1, 0],\n        ...       [1, 1, 1],\n        ...       [0, 1, 0]]\n        &gt;&gt;&gt; start_point = (1, 1)\n        &gt;&gt;&gt; # get a list of 4 steps all filling\n        &gt;&gt;&gt; xs = [*hole_filling_X_gen(img, se, start_point, max_itiration = 4)]\n        &gt;&gt;&gt; plot_morphology(xs) # Custom function to show the matrix\n    \"\"\"\n    X_prev = [[0] * len(matrix[0]) for _ in range(len(matrix))]\n    X_prev[x_0_indx[0]][x_0_indx[1]] = 1\n    complement_A = DO.complement(matrix,1)\n    yield X_prev\n\n    for _ in range(max_itiration):\n        # Compute X_k = (X_{k-1} \u2295 B) \u2229 A^c\n        dilated_X_prev  = dilation(X_prev, se)\n        X_k = intersection(dilated_X_prev, complement_A)\n\n        # Check for convergence\n        if X_k == X_prev:\n            yield X_k\n            break\n\n        # Update X_prev for next iteration\n        X_prev = X_k\n        yield X_k\n</code></pre>"},{"location":"morphology/#DIP.morphology.internal_extraction","title":"<code>internal_extraction(matrix, se)</code>","text":"<p>Extracts internal structures from a binary image by performing morphological erosion  followed by subtraction from the original image. This operation highlights inner  boundaries of objects in the image.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>Matrix Original binary image represented as a 2D list of 0s and 1s.</p> required <code>`se`</code> <code>Matrix</code> <p>Structuring element used for erosion, represented as a 2D list.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>Resulting binary image containing only the internal boundaries.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; img = [[0, 0, 0, 0],\n...        [0, 1, 1, 0],\n...        [0, 1, 1, 0],\n...        [0, 0, 0, 0]]\n&gt;&gt;&gt; se = [[1, 1],\n...       [1, 1]]\n&gt;&gt;&gt; result = internal_extraction(img, se)\n&gt;&gt;&gt; # Result will show the inner boundary of the 2x2 square\n</code></pre> Source code in <code>DIP/morphology.py</code> Python<pre><code>def internal_extraction(matrix: Matrix, se: Matrix) -&gt; Matrix:\n    \"\"\"\n    Extracts internal structures from a binary image by performing morphological erosion \n    followed by subtraction from the original image. This operation highlights inner \n    boundaries of objects in the image.\n\n    Parameters:\n        `matrix` (Matrix): Matrix Original binary image represented as a 2D list of 0s and 1s.\n        `se` (Matrix): Structuring element used for erosion, represented as a 2D list.\n\n    Returns:\n        Matrix: Resulting binary image containing only the internal boundaries.\n\n    Examples:\n        &gt;&gt;&gt; img = [[0, 0, 0, 0],\n        ...        [0, 1, 1, 0],\n        ...        [0, 1, 1, 0],\n        ...        [0, 0, 0, 0]]\n        &gt;&gt;&gt; se = [[1, 1],\n        ...       [1, 1]]\n        &gt;&gt;&gt; result = internal_extraction(img, se)\n        &gt;&gt;&gt; # Result will show the inner boundary of the 2x2 square\n    \"\"\"\n    eroded_matrix = erosion(matrix, se)\n\n    # Subtract the eroded image from the original image to get the external boundary\n    result_matrix = [[DO.clip(matrix[i][j] - eroded_matrix[i][j],0,1) for j in range(len(matrix[0]))] for i in range(len(matrix))]\n\n    return result_matrix\n</code></pre>"},{"location":"morphology/#DIP.morphology.morphology_gradient","title":"<code>morphology_gradient(matrix, se)</code>","text":"<p>Computes the morphological gradient of a binary image by taking the difference  between dilated and eroded versions of the image. This operation highlights  all boundaries in the image.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>Matrix Original binary image represented as a 2D list of 0s and 1s.</p> required <code>`se`</code> <code>Matrix</code> <p>Structuring element used for erosion, represented as a 2D list.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>Resulting gradient image showing all boundaries.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; img = [[0, 0, 0, 0],\n...        [0, 1, 1, 0],\n...        [0, 1, 1, 0],\n...        [0, 0, 0, 0]]\n&gt;&gt;&gt; se = [[1, 1],\n...       [1, 1]]\n&gt;&gt;&gt; result = morphology_gradient(img, se)\n&gt;&gt;&gt; # Result will show both inner and outer boundaries\n</code></pre> Source code in <code>DIP/morphology.py</code> Python<pre><code>def morphology_gradient(matrix: Matrix, se: Matrix) -&gt; Matrix:\n    \"\"\"\n    Computes the morphological gradient of a binary image by taking the difference \n    between dilated and eroded versions of the image. This operation highlights \n    all boundaries in the image.\n\n    Parameters:\n        `matrix` (Matrix): Matrix Original binary image represented as a 2D list of 0s and 1s.\n        `se` (Matrix): Structuring element used for erosion, represented as a 2D list.\n\n    Returns:\n        Matrix: Resulting gradient image showing all boundaries.\n\n    Examples:\n        &gt;&gt;&gt; img = [[0, 0, 0, 0],\n        ...        [0, 1, 1, 0],\n        ...        [0, 1, 1, 0],\n        ...        [0, 0, 0, 0]]\n        &gt;&gt;&gt; se = [[1, 1],\n        ...       [1, 1]]\n        &gt;&gt;&gt; result = morphology_gradient(img, se)\n        &gt;&gt;&gt; # Result will show both inner and outer boundaries\n    \"\"\"\n    dilated_matrix = dilation(matrix, se)\n\n    eroded_matrix = erosion(matrix, se)\n\n    result_matrix = [[abs(dilated_matrix[i][j] - eroded_matrix[i][j]) for j in range(len(matrix[0]))] for i in range(len(matrix))]\n\n    return result_matrix\n</code></pre>"},{"location":"morphology/#DIP.morphology.opening","title":"<code>opening(matrix, se)</code>","text":"<p>Perform opening operation on a matrix using a given structuring element (se).</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The original binary matrix on which the opening operation is applied.</p> required <code>`se`</code> <code>Matrix</code> <p>The structuring element used for the opening operation.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The result of the opening operation on the matrix.</p> Description <p>The opening process consists of an erosion followed by a dilation using the same structuring element. This operation is useful for removing small objects from the foreground (usually taken as the bright pixels) of an image, placing them in the background, while preserving the shape and size of larger objects in the image.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; matrix = [[0,0,0,0,0,0], \n...          [0,1,1,1,1,0], \n...          [0,1,1,0,1,0],\n...          [0,1,1,0,1,0],\n...          [0,1,1,1,1,0]]\n&gt;&gt;&gt; se = [[1,1]\n        ,[0,1]]\n&gt;&gt;&gt; result = opening(matrix,se)\n&gt;&gt;&gt; result\n[[0, 0, 0, 0, 0, 0]\n,[0, 1, 1, 1, 1, 0]\n,[0, 1, 1, 0, 1, 0]\n,[0, 1, 1, 0, 0, 0]\n,[0, 0, 1, 0, 0, 0]]\n</code></pre> Source code in <code>DIP/morphology.py</code> Python<pre><code>def opening(matrix: Matrix, se: Matrix) -&gt; Matrix:\n    \"\"\"\n    Perform opening operation on a matrix using a given structuring element (se).\n\n    Parameters:\n        `matrix` (Matrix): The original binary matrix on which the opening operation is applied.\n        `se` (Matrix): The structuring element used for the opening operation.\n\n    Returns:\n        Matrix: The result of the opening operation on the matrix.\n\n    Description:\n        The opening process consists of an erosion followed by a dilation using the same structuring element.\n        This operation is useful for removing small objects from the foreground (usually taken as the bright pixels) of an image,\n        placing them in the background, while preserving the shape and size of larger objects in the image.\n\n    Examples:\n        &gt;&gt;&gt; matrix = [[0,0,0,0,0,0], \n        ...          [0,1,1,1,1,0], \n        ...          [0,1,1,0,1,0],\n        ...          [0,1,1,0,1,0],\n        ...          [0,1,1,1,1,0]]\n        &gt;&gt;&gt; se = [[1,1]\n                ,[0,1]]\n        &gt;&gt;&gt; result = opening(matrix,se)\n        &gt;&gt;&gt; result\n        [[0, 0, 0, 0, 0, 0]\n        ,[0, 1, 1, 1, 1, 0]\n        ,[0, 1, 1, 0, 1, 0]\n        ,[0, 1, 1, 0, 0, 0]\n        ,[0, 0, 1, 0, 0, 0]]\n    \"\"\"\n    eroded = erosion(matrix, se)\n    result = dilation(eroded, se)\n    return result\n</code></pre>"},{"location":"morphology/#DIP.morphology.practical_dilation","title":"<code>practical_dilation(matrix, se)</code>","text":"<p>Perform dilation operation on a matrix using a given structuring element (se).</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The original binary matrix on which the dilation is applied.</p> required <code>`se`</code> <code>Matrix</code> <p>The structuring element used for the dilation operation.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The result of the dilation operation on the matrix.</p> Description <p>The dilation process involves sliding the <code>se</code> over the matrix and checking if any '1' pixel in the <code>se</code> aligns with a '1' pixel in the matrix neighborhood. If such an overlap is found, the center pixel of the neighborhood is set to '1' in the output matrix; otherwise, it remains '0'. The output matrix has the same size as the input matrix.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; matrix = [[1, 0, 0, 0],\n...           [0, 0, 0, 0],\n...           [0, 0, 0, 0],\n...           [0, 0, 0, 1]]\n&gt;&gt;&gt; se = [[1, 1],\n...       [1, 1]]\n&gt;&gt;&gt; result = dilation(matrix, se)\n&gt;&gt;&gt; result\n[[1, 1, 0, 0],\n[1, 1, 0, 0],\n[0, 0, 0, 0],\n[0, 0, 0, 1]]\n</code></pre> Source code in <code>DIP/morphology.py</code> Python<pre><code>def practical_dilation(matrix: Matrix, se: Matrix) -&gt; Matrix:\n    \"\"\"\n    Perform dilation operation on a matrix using a given structuring element (se).\n\n    Parameters:\n        `matrix` (Matrix): The original binary matrix on which the dilation is applied.\n        `se` (Matrix): The structuring element used for the dilation operation.\n\n    Returns:\n        Matrix: The result of the dilation operation on the matrix.\n\n    Description:\n        The dilation process involves sliding the `se` over the matrix and checking if any '1' pixel in the `se` aligns with a '1' pixel in the matrix neighborhood.\n        If such an overlap is found, the center pixel of the neighborhood is set to '1' in the output matrix; otherwise, it remains '0'.\n        The output matrix has the same size as the input matrix.\n\n    Examples:\n        &gt;&gt;&gt; matrix = [[1, 0, 0, 0],\n        ...           [0, 0, 0, 0],\n        ...           [0, 0, 0, 0],\n        ...           [0, 0, 0, 1]]\n        &gt;&gt;&gt; se = [[1, 1],\n        ...       [1, 1]]\n        &gt;&gt;&gt; result = dilation(matrix, se)\n        &gt;&gt;&gt; result\n        [[1, 1, 0, 0],\n        [1, 1, 0, 0],\n        [0, 0, 0, 0],\n        [0, 0, 0, 1]]\n    \"\"\"\n    height = len(matrix)\n    width = len(matrix[0])\n\n    se_h = len(se)\n    se_w = len(se[0])\n\n    # output will be same size as original in this case\n    output_mat = [[0 for _ in range(width)] for _ in range(height)]\n\n    # make bigger padded matrix \n    matrix = DN.pad(matrix,(se_w,se_h))\n\n    for i in range(height):\n        for j in range(width):\n            window = slice_matrix(matrix,(i,i+se_h), (j,j+se_w))\n            output_mat[i][j] = max(filter_by_kernel(window, se))\n\n    return output_mat\n</code></pre>"},{"location":"neighborhood_operations/","title":"DIP.neighborhood_operations","text":""},{"location":"neighborhood_operations/#DIP.neighborhood_operations.Kernels","title":"<code>Kernels</code>","text":"<p>Collection of common image processing kernels used for filtering and edge detection.</p> <p>Each kernel is represented as a 2D list of coefficients that can be applied to an image through convolution or correlation operations.</p> Source code in <code>DIP/neighborhood_operations.py</code> Python<pre><code>class Kernels:\n    \"\"\"\n    Collection of common image processing kernels used for filtering and edge detection.\n\n    Each kernel is represented as a 2D list of coefficients that can be applied to an image\n    through convolution or correlation operations.\n    \"\"\"\n\n    # Averaging filter with uniform weights\n    smoothing_filter = [\n        [0.111, 0.111, 0.111],\n        [0.111, 0.111, 0.111],\n        [0.111, 0.111, 0.111]\n    ]  # 1/9 weight for each pixel\n\n    # Gaussian-like smoothing filter with center-weighted coefficients\n    weighted_smoothing_filter = [\n        [0.0625, 0.125, 0.0625],\n        [0.125, 0.25, 0.125],\n        [0.0625, 0.125, 0.0625]\n    ]  # Approximates Gaussian blur\n\n    # Enhancement filter that emphasizes edges\n    high_pass_filter = [\n        [-1, -1, -1],\n        [-1, 8, -1],\n        [-1, -1, -1]\n    ]\n\n    # Roberts cross-gradient operators\n    robert_operator = [\n        [-1, 0],\n        [0, 1]\n    ]  # Detects diagonal edges\n\n    # Prewitt gradient operators\n    prewitt_operator = [\n        [-1, 0, 1],\n        [-1, 0, 1],\n        [-1, 0, 1]\n    ]  # Detects vertical edges (horizontal gradient)\n\n    # Sobel gradient operators\n    sobel_operator = [\n        [-1, 0, 1],\n        [-2, 0, 2],\n        [-1, 0, 1]\n    ]  # Enhanced edge detection with central emphasis\n\n    # Laplacian operator for edge detection\n    laplacian_operator = [\n        [0, 1, 0],\n        [1, -4, 1],\n        [0, 1, 0]\n    ]  # Second derivative operator\n\n    # 3*3 gaussian kernel with sigma = 2\n    gaussian_kernel = [\n        [0.1019, 0.1154, 0.1019],\n        [0.1154, 0.1308, 0.1154],\n        [0.1019, 0.1154, 0.1019]\n        ]\n</code></pre>"},{"location":"neighborhood_operations/#DIP.neighborhood_operations.adaptive_filter","title":"<code>adaptive_filter(matrix, kernel_dim, pad_with=None)</code>","text":"<p>Applies adaptive local noise reduction filter using local statistics. The filter adapts to local image properties</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>Input image as 2D list</p> required <code>`kernel_dim`</code> <code>Tuple[int, int]</code> <p>(width, height) of the neighborhood window</p> required <code>`pad_with`</code> <code>int</code> <p>Padding value for border handling</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>Filtered image with noise reduction</p> <p>steps: - calculate global mean <code>mu_g</code> to calculate population variance <code>sigma_g</code> - calculate local mean <code>mu</code> and sample variance <code>sigma</code> - get the estimate value of of pixel (x,y) - pixel_est = mu + sigma * (pixel - mu)/(sigma + sigma_g)</p> Source code in <code>DIP/neighborhood_operations.py</code> Python<pre><code>def adaptive_filter(matrix, kernel_dim:Tuple[int,int], pad_with:Optional[int] = None) -&gt; Matrix:\n    \"\"\"\n    Applies adaptive local noise reduction filter using local statistics. The filter adapts to local image properties\n\n    Parameters:\n        `matrix` (Matrix): Input image as 2D list\n        `kernel_dim` (Tuple[int, int]): (width, height) of the neighborhood window\n        `pad_with` (int, optional): Padding value for border handling\n\n    Returns:\n        Matrix: Filtered image with noise reduction\n\n    steps:\n    - calculate global mean `mu_g` to calculate population variance `sigma_g`\n    - calculate local mean `mu` and sample variance `sigma`\n    - get the estimate value of of pixel (x,y)\n    - pixel_est = mu + sigma * (pixel - mu)/(sigma + sigma_g)\n    \"\"\"\n    def calculate_statistics(values) -&gt; Tuple[float, float]:\n        n = len(values)\n        mean = sum(values) / n\n        variance = sum((x - mean) ** 2 for x in values) / n - 1\n        return mean, variance\n\n    k_width = kernel_dim[0]\n    k_hieght = kernel_dim[1]\n    kernel_size = k_width * k_hieght\n\n    output_mat = deepcopy(matrix)\n\n\n\n    # calculate population variance `sigma_g`\n    flat_mat = flatten_matrix(matrix)\n    mat_size = len(flat_mat)\n    mu_g = sum(flat_mat) / mat_size\n    sigma_g = sum((x - mu_g) ** 2 for x in flat_mat) / mat_size\n\n    for neighbors, center in _get_neighborhood_and_center(matrix,(k_width,k_hieght),pad_with=pad_with):\n        # calculate local mean `mu` and sample variance `sigma`\n        mu = sum(elem for rows in neighbors for elem in rows)/kernel_size\n        sigma = sum((elem - mu)**2 for rows in matrix for elem in rows)/(kernel_size-1)\n\n        current_pixel = output_mat[center[0]][center[1]]\n\n        output_mat[center[0]][center[1]] = DP.normal_round(mu + sigma * (current_pixel - mu)/(sigma + sigma_g))\n\n    return output_mat\n</code></pre>"},{"location":"neighborhood_operations/#DIP.neighborhood_operations.apply_filter","title":"<code>apply_filter(matrix, kernel, pad_with=None, bit_depth=None)</code>","text":"<p>wrapper on correlate function that round the output</p> Source code in <code>DIP/neighborhood_operations.py</code> Python<pre><code>def apply_filter(matrix: Matrix, kernel: Matrix, pad_with:Optional[int] = None, bit_depth:Optional[int] = None) -&gt; Matrix:\n    \"\"\"wrapper on correlate function that round the output\"\"\"\n\n    return [[DP.normal_round(v) for v in row] for row in correlate(matrix, kernel, pad_with, bit_depth)]\n</code></pre>"},{"location":"neighborhood_operations/#DIP.neighborhood_operations.apply_gradient_operator","title":"<code>apply_gradient_operator(matrix, kernel, bit_depth=None, pad_with=None)</code>","text":"<p>Generic function to apply gradient operators using pure Python.</p> <p>Parameters::     <code>matrix</code>: Input image as 2D list     <code>kernel</code>: Primary gradient kernel     <code>bit_depth</code>: Bit depth for output value clipping     <code>pad_with</code>: Padding value for border handling</p> <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>Edge-detected image</p> Source code in <code>DIP/neighborhood_operations.py</code> Python<pre><code>def apply_gradient_operator(\n    matrix: Matrix,\n    kernel: Matrix,\n    bit_depth: Optional[int] = None,\n    pad_with: Optional[int] = None\n) -&gt; Matrix:\n    \"\"\"\n    Generic function to apply gradient operators using pure Python.\n\n    Parameters::\n        `matrix`: Input image as 2D list\n        `kernel`: Primary gradient kernel\n        `bit_depth`: Bit depth for output value clipping\n        `pad_with`: Padding value for border handling\n\n    Returns:\n        Matrix: Edge-detected image\n    \"\"\"\n    rotated_kernel = rotate_90(kernel)\n\n    gradient_x = correlate(matrix, kernel, pad_with, bit_depth) #f1\n    gradient_y = correlate(matrix, rotated_kernel, pad_with, bit_depth) #f2\n\n    height, width = len(gradient_x), len(gradient_x[0])\n    result = [[0] * width for _ in range(height)]\n\n    for r in range(height):\n        for c in range(width):\n            magnitude = m.sqrt(gradient_x[r][c]**2 + gradient_y[r][c]**2)\n            result[r][c] = DP.normal_round(magnitude)\n\n    return result\n</code></pre>"},{"location":"neighborhood_operations/#DIP.neighborhood_operations.correlate","title":"<code>correlate(matrix, kernel, pad_with=None, bit_depth=None)</code>","text":"<p>Perform convolution operation on a matrix using a given kernel.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The original matrix on which convolution is applied.</p> required <code>`kernel`</code> <code>Matrix</code> <p>The convolution kernel.</p> required <code>`pad_with`</code> <code>int</code> <p>Padding value border handling. If <code>None</code>, no padding is applied, output is smaller than input. Defaults to <code>None</code>.</p> required <p>Returns:</p> Type Description <code>Matrix</code> <p><code>Matrix</code>: The result of convolving the matrix with the kernel.</p> Description <p>This function performs correlation operation on the <code>matrix</code> using the specified <code>kernel</code>. It supports optional padding with a specified value. Correlation is performed by sliding the kernel over the matrix and computing the dot product between the kernel and the neighborhood of each pixel.</p> <p>Examples:</p> <p>matrix = [[1, 2, 3], ...           [4, 5, 6], ...           [7, 8, 9]] kernel = [[1, 0, -1], ...           [1, 0, -1], ...           [1, 0, -1]] result = correlate(matrix, kernel,pad_with=0) result [[-7, -4, 7], [-15, -6, 15], [-13, -4, 13]]</p> Source code in <code>DIP/neighborhood_operations.py</code> Python<pre><code>def correlate(matrix: Matrix, kernel: Matrix, pad_with:Optional[int] = None, bit_depth:Optional[int] = None) -&gt; Matrix:\n    \"\"\"\n    Perform convolution operation on a matrix using a given kernel.\n\n    Parameters:\n        `matrix` (Matrix): The original matrix on which convolution is applied.\n        `kernel` (Matrix): The convolution kernel.\n        `pad_with` (int, optional): Padding value border handling. If `None`, no padding is applied, output is smaller than input. Defaults to `None`.\n\n    Returns:\n        `Matrix`: The result of convolving the matrix with the kernel.\n\n    Description:\n        This function performs correlation operation on the `matrix` using the specified `kernel`.\n        It supports optional padding with a specified value.\n        Correlation is performed by sliding the kernel over the matrix and computing the dot product between the kernel and the neighborhood of each pixel.\n    Examples:\n    &gt;&gt;&gt; matrix = [[1, 2, 3],\n    ...           [4, 5, 6],\n    ...           [7, 8, 9]]\n    &gt;&gt;&gt; kernel = [[1, 0, -1],\n    ...           [1, 0, -1],\n    ...           [1, 0, -1]]\n    &gt;&gt;&gt; result = correlate(matrix, kernel,pad_with=0)\n    &gt;&gt;&gt; result\n    [[-7, -4, 7],\n    [-15, -6, 15],\n    [-13, -4, 13]]\n    \"\"\"\n    if bit_depth is None:\n        bit_depth = bit_depth_from_mat(matrix)\n\n    max_value = 2 ** bit_depth - 1\n\n    height = len(matrix)\n    width = len(matrix[0])\n    k_w = len(kernel[0])\n    k_h = len(kernel)\n\n    if pad_with is None:\n        # make smaller matrix\n        output_mat = [[pad_with for _ in range(width - k_w + 1)] for _ in range(height - k_h + 1)]\n\n    elif isinstance(pad_with,int):\n        # output will be same size as original in this case\n        output_mat = [[pad_with for _ in range(width)] for _ in range(height)]\n\n        matrix = pad(matrix,(k_w,k_h),pad_with)\n        # get the new dimentions to work on\n        height = len(matrix)\n        width = len(matrix[0])\n    else:\n        raise ValueError(\"padding must be None or integer\")\n\n    for row in range(height - k_h + 1):\n        for col in range(width - k_w + 1):\n            # getting the values same size as the filter \n            neighborhood = slice_matrix(matrix,(row,row + k_h),(col, col + k_w))\n            # for every row in neighborhood and kernel and for each element in both rows multiply elements then sum all\n            output_mat[row][col] = clip(round(sum(e * v for e,v in zip(flatten_matrix(neighborhood), flatten_matrix(kernel))),2),0,max_value)\n\n    return output_mat\n</code></pre>"},{"location":"neighborhood_operations/#DIP.neighborhood_operations.create_gaussian_kernel","title":"<code>create_gaussian_kernel(size, sigma)</code>","text":"<p>Create a 2D Gaussian kernel (filter) for image smoothing.</p> <p>The Gaussian kernel is created using the 2D Gaussian function: G(x,y) = (1/(2\u03c0*\u03c3\u00b2)) * e^(-(x\u00b2 + y\u00b2)/(2\u03c3\u00b2))</p> <p>Where: - x,y are distances from the kernel center - \u03c3 (sigma) controls the spread of the Gaussian - Size determines the kernel dimensions (must be odd)</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Kernel size (must be odd). Larger size = more pixels involved in smoothing</p> required <code>sigma</code> <code>float</code> <p>Standard deviation of Gaussian. Larger sigma = more blurring</p> required <p>Returns:</p> Type Description <code>List[List[float]]</code> <p>2D list representing the Gaussian kernel, normalized to sum to 1</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If size is even or sigma is not positive</p> Source code in <code>DIP/neighborhood_operations.py</code> Python<pre><code>def create_gaussian_kernel(size: int, sigma: float) -&gt; List[List[float]]:\n    \"\"\"\n    Create a 2D Gaussian kernel (filter) for image smoothing.\n\n    The Gaussian kernel is created using the 2D Gaussian function:\n    G(x,y) = (1/(2\u03c0*\u03c3\u00b2)) * e^(-(x\u00b2 + y\u00b2)/(2\u03c3\u00b2))\n\n    Where:\n    - x,y are distances from the kernel center\n    - \u03c3 (sigma) controls the spread of the Gaussian\n    - Size determines the kernel dimensions (must be odd)\n\n    Parameters:\n        size: Kernel size (must be odd). Larger size = more pixels involved in smoothing\n        sigma: Standard deviation of Gaussian. Larger sigma = more blurring\n\n    Returns:\n        2D list representing the Gaussian kernel, normalized to sum to 1\n\n    Raises:\n        ValueError: If size is even or sigma is not positive\n    \"\"\"\n    from math import exp, pi\n\n    # Validate inputs\n    if size % 2 == 0:\n        raise ValueError(\"Kernel size must be odd to have a clear center point\")\n    if sigma &lt;= 0:\n        raise ValueError(\"Sigma must be positive\")\n\n    # Calculate center point of kernel\n    center = size // 2\n\n    # Calculate normalization factor: 1/(2\u03c0*\u03c3\u00b2)\n    # This is part of the 2D Gaussian formula\n    norm_factor = 1 / (2 * pi * sigma * sigma)\n\n    # Initialize kernel and running sum for normalization\n    kernel = []\n    kernel_sum = 0.0\n\n    # Generate kernel values\n    for i in range(size):\n        row = []\n        for j in range(size):\n            # Calculate distance from center (x,y coordinates relative to center)\n            x = i - center\n            y = j - center\n\n            # Calculate squared distance from center\n            # This is (x\u00b2 + y\u00b2) in the formula\n            squared_dist = x*x + y*y\n\n            # Calculate exponent: -(x\u00b2 + y\u00b2)/(2\u03c3\u00b2)\n            exponent = -squared_dist / (2 * sigma * sigma)\n\n            # Calculate Gaussian value using the complete formula\n            value = norm_factor * exp(exponent)\n\n            # Add to running sum for later normalization\n            kernel_sum += value\n            row.append(value)\n        kernel.append(row)\n\n    # Normalize kernel so all values sum to 1\n    # This ensures image brightness is preserved after filtering\n    for i in range(size):\n        for j in range(size):\n            kernel[i][j] = round(kernel[i][j] / kernel_sum,4)\n\n    return kernel\n</code></pre>"},{"location":"neighborhood_operations/#DIP.neighborhood_operations.get_pixel_neighborhoods","title":"<code>get_pixel_neighborhoods(matrix, kernel_dim, pixel_pos)</code>","text":"<p>Extracts a neighborhood of a pixel from a matrix based on the given kernel size.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The original matrix from which to extract the neighborhood.</p> required <code>`pixel_pos`</code> <code>Tuple[int, int]</code> <p>The position of the pixel around which to extract the neighborhood.</p> required <code>`kernel_dim`</code> <code>Tuple[int, int]</code> <p>Dimensions of the kernel used to define the neighborhood size.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>A matrix representing the neighborhood of the specified pixel.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; matrix = [[1, 2, 3, 4],\n...           [5, 6, 7, 8],\n...           [9, 10, 11, 12],\n...           [13, 14, 15, 16]]\n&gt;&gt;&gt; pixel_pos = (1, 1)\n&gt;&gt;&gt; kernel_dim = (3, 3)\n&gt;&gt;&gt; neighborhood = neighborhoods_of_pixel(matrix, pixel_pos, kernel_dim)\n&gt;&gt;&gt; neighborhood\n[[1, 2, 3],\n[5, 6, 7],\n[9, 10, 11]]\n</code></pre> Source code in <code>DIP/neighborhood_operations.py</code> Python<pre><code>def get_pixel_neighborhoods(matrix: Matrix, kernel_dim: Tuple[int, int], pixel_pos: Tuple[int, int]) -&gt; Matrix:\n    \"\"\"\n    Extracts a neighborhood of a pixel from a matrix based on the given kernel size.\n\n    Parameters:\n        `matrix` (Matrix): The original matrix from which to extract the neighborhood.\n        `pixel_pos` (Tuple[int, int]): The position of the pixel around which to extract the neighborhood.\n        `kernel_dim` (Tuple[int, int]): Dimensions of the kernel used to define the neighborhood size.\n\n    Returns:\n        Matrix: A matrix representing the neighborhood of the specified pixel.\n\n    Examples:\n        &gt;&gt;&gt; matrix = [[1, 2, 3, 4],\n        ...           [5, 6, 7, 8],\n        ...           [9, 10, 11, 12],\n        ...           [13, 14, 15, 16]]\n        &gt;&gt;&gt; pixel_pos = (1, 1)\n        &gt;&gt;&gt; kernel_dim = (3, 3)\n        &gt;&gt;&gt; neighborhood = neighborhoods_of_pixel(matrix, pixel_pos, kernel_dim)\n        &gt;&gt;&gt; neighborhood\n        [[1, 2, 3],\n        [5, 6, 7],\n        [9, 10, 11]]\n    \"\"\"\n\n\n    width = len(matrix[0])\n    height = len(matrix)\n\n    k_w = kernel_dim[0]\n    k_h = kernel_dim[1]\n    left,top = get_center(k_w,k_h)\n    # lenght - indx = lenght - 1 = indx\n    right = k_w - left - 1\n    down = k_h - top - 1\n\n    # Calculate the starting position for the neighborhood\n    start_row = max(0, pixel_pos[0] - left)\n    start_col = max(0, pixel_pos[1] - top)\n\n    # Calculate the ending position for the neighborhood\n    end_row = min(height - 1, pixel_pos[0] + down)\n    end_col = min(width - 1, pixel_pos[1] + right)\n\n    # Calculate the size of the neighborhood matrix\n    neighborhood_width = end_col - start_col + 1\n    neighborhood_height = end_row - start_row + 1\n\n    # Create a zero-filled matrix of the shape of the kernel\n    output_matrix = [[0 for _ in range(k_w)] for _ in range(k_h)]\n\n    # Calculate the shift amount\n    shift_row = max(0, top - pixel_pos[0])\n    shift_col = max(0, left - pixel_pos[1])\n\n    # Copy values from the original matrix to the output matrix\n    for i in range(neighborhood_height):\n        for j in range(neighborhood_width):\n            output_matrix[i + shift_row][j + shift_col] = matrix[start_row + i][start_col + j]\n\n    return output_matrix\n</code></pre>"},{"location":"neighborhood_operations/#DIP.neighborhood_operations.outlier_method","title":"<code>outlier_method(matrix, threshold)</code>","text":"<p>Applies an outlier detection and correction method to a matrix based on a threshold. If the mean value of a pixel's neighborhood exceeds the threshold, the pixel value is replaced with the rounded neighborhood mean. This helps to smooth out isolated outliers in the matrix.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The original matrix on which the outlier method is applied.</p> required <code>`threshold`</code> <code>float</code> <p>The threshold value used for determining outliers.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>A new matrix with outliers replaced by neighborhood means where applicable.</p>"},{"location":"neighborhood_operations/#DIP.neighborhood_operations.outlier_method--notes","title":"Notes","text":"<ul> <li>The 3x3 mean kernel used in this method is defined as:     mean_kernel = [[0.125, 0.125, 0.125],                     [0.125, 0, 0.125],                     [0.125, 0.125, 0.125]]</li> <li>The kernel excludes the center pixel from the mean computation.</li> <li>Only pixels with a neighborhood mean greater than or equal to the threshold   are updated to the neighborhood mean.</li> </ul> <p>Examples:</p> <p>img = [[10, 20, 30], ...        [40, 50, 60], ...        [70, 80, 90]] processed_img = outlier_method(img, threshold=50)</p> Source code in <code>DIP/neighborhood_operations.py</code> Python<pre><code>def outlier_method(matrix: Matrix, threshold:float) -&gt; Matrix:\n    \"\"\"\n    Applies an outlier detection and correction method to a matrix based on a threshold.\n    If the mean value of a pixel's neighborhood exceeds the threshold, the pixel value is\n    replaced with the rounded neighborhood mean. This helps to smooth out isolated outliers\n    in the matrix.\n\n    Parameters:\n        `matrix` (Matrix): The original matrix on which the outlier method is applied.\n        `threshold` (float): The threshold value used for determining outliers.\n\n    Returns:\n        Matrix: A new matrix with outliers replaced by neighborhood means where applicable.\n\n    Notes\n    -----\n    - The 3x3 mean kernel used in this method is defined as:\n        mean_kernel = [[0.125, 0.125, 0.125], \n                       [0.125, 0, 0.125], \n                       [0.125, 0.125, 0.125]]\n    - The kernel excludes the center pixel from the mean computation.\n    - Only pixels with a neighborhood mean greater than or equal to the threshold\n      are updated to the neighborhood mean.\n\n    Examples:\n    &gt;&gt;&gt; img = [[10, 20, 30],\n    ...        [40, 50, 60],\n    ...        [70, 80, 90]]\n    &gt;&gt;&gt; processed_img = outlier_method(img, threshold=50)\n    \"\"\"\n\n    # Deep copy the input matrix to avoid modifying the original matrix\n    output_mat = deepcopy(matrix)\n\n    # Define the 3x3 mean kernel for neighborhood calculation\n    # for the neighberhood multiply by 1/8 in all places but the center\n    mean_kernel = [[0.125, 0.125, 0.125], [0.125, 0, 0.125], [0.125, 0.125, 0.125]]\n    k_height = len(mean_kernel)\n    k_width = len(mean_kernel[0])\n\n    # Iterate through each neighborhood with its center pixel\n    for neighbors, center in _get_neighborhood_and_center(output_mat, (k_width, k_height)):\n        # Calculate the mean value of the neighborhood using the mean kernel\n        neighborhood_mean = sum(neighbors[row][col] * mean_kernel[row][col] for row in range(3) for col in range(3))\n\n        # Replace the center pixel with the rounded neighborhood mean if it exceeds the threshold\n        if neighborhood_mean &gt;= threshold:\n            output_mat[center[0]][center[1]] = DP.normal_round(neighborhood_mean)\n\n    return output_mat\n</code></pre>"},{"location":"neighborhood_operations/#DIP.neighborhood_operations.pad","title":"<code>pad(matrix, kernel_shape, pad_with=0)</code>","text":"<p>Pads a matrix with a specified value.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The original matrix to be padded.</p> required <code>`kernel_shape`</code> <code>Tuple[int, int]</code> <p>(width, height) of the kernel, used to determine the padding.</p> required <code>`pad_with`</code> <code>int</code> <p>Value to pad the matrix with. Defaults is 0.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The padded matrix.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If pad_value is not an integer</p> <p>Examples:</p> <p>mat=[[3,1,5],         [3,0,1],         [5,4,1],         [0,2,2]] display_matrices([pad(mat, (2,4))]) ... [ 0 0 0 0 ] ... [ 0 0 0 0 ] ... [ 0 3 1 5 ] ... [ 0 3 0 1 ] ... [ 0 5 4 1 ] ... [ 0 0 2 2 ] ... [ 0 0 0 0 ]</p> Source code in <code>DIP/neighborhood_operations.py</code> Python<pre><code>def pad(matrix: Matrix, kernel_shape: Tuple[int,int],pad_with: int = 0) -&gt; Matrix:\n    \"\"\"\n    Pads a matrix with a specified value.\n\n    Parameters:\n        `matrix` (Matrix): The original matrix to be padded.\n        `kernel_shape` (Tuple[int,int]): (width, height) of the kernel, used to determine the padding.\n        `pad_with` (int): Value to pad the matrix with. Defaults is 0.\n\n    Returns:\n        Matrix: The padded matrix.\n\n    Raises:\n        ValueError: If pad_value is not an integer\n\n    Examples:\n    &gt;&gt;&gt; mat=[[3,1,5],\n            [3,0,1],\n            [5,4,1],\n            [0,2,2]]\n    &gt;&gt;&gt; display_matrices([pad(mat, (2,4))])\n    ... [ 0 0 0 0 ]\n    ... [ 0 0 0 0 ]\n    ... [ 0 3 1 5 ]\n    ... [ 0 3 0 1 ]\n    ... [ 0 5 4 1 ]\n    ... [ 0 0 2 2 ]\n    ... [ 0 0 0 0 ]\n    \"\"\"\n\n    if not isinstance(pad_with, int):\n        raise ValueError(\"pad_with must be an integer\")\n    width = len(matrix[0])\n\n    k_w, k_h = kernel_shape\n    # get the how much center is away from each corner of the kernel\n    # the index is number of rows or column away from this point\n    pad_top,pad_left = get_center(k_w,k_h)\n    # lenght - indx = lenght - 1 = indx\n    pad_right = k_w - pad_left - 1\n    pad_bottom = k_h - pad_top - 1\n\n    padded_width = width + pad_left + pad_right\n\n    # Create top padding rows\n    result = [[pad_with] * padded_width for _ in range(pad_top)]\n\n    # Add rows with content\n    for row in matrix:\n        padded_row = [pad_with] * pad_left + row + [pad_with] * pad_right\n        result.append(padded_row)\n\n    # Add bottom padding rows\n    result.extend([[pad_with] * padded_width for _ in range(pad_bottom)])\n\n    return result\n</code></pre>"},{"location":"neighborhood_operations/#DIP.neighborhood_operations.prewitt_operator","title":"<code>prewitt_operator(matrix, bit_depth=None, pad_with=None)</code>","text":"<p>Applies the Prewitt operator for edge detection.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>Input image as a 2D list</p> required <code>`bit_depth`</code> <code>int</code> <p>Bit depth for output value clipping</p> required <code>`pad_with`</code> <code>int</code> <p>Padding value for border handling</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>Edge-detected image</p>"},{"location":"neighborhood_operations/#DIP.neighborhood_operations.prewitt_operator--notes","title":"Notes","text":"<p>The Prewitt operator uses two 3\u00d73 kernels to compute horizontal and vertical gradients: Gx = [[-1, 0, 1],     Gy = [[-1, -1, -1],       [-1, 0, 1],           [ 0,  0,  0],       [-1, 0, 1]]           [ 1,  1,  1]]</p> <p>The final magnitude is computed as: sqrt(Gx\u00b2 + Gy\u00b2)</p> <p>Examples:</p> <p>img = [[1, 2, 3], ...        [4, 5, 6], ...        [7, 8, 9]] edges = prewitt_operator(img, pad_with=0)</p> Source code in <code>DIP/neighborhood_operations.py</code> Python<pre><code>def prewitt_operator(matrix: Matrix, bit_depth: Optional[int] = None, pad_with: Optional[int] = None) -&gt; Matrix:\n    \"\"\"\n    Applies the Prewitt operator for edge detection.\n\n    Parameters:\n        `matrix` (Matrix): Input image as a 2D list\n        `bit_depth` (int, optional): Bit depth for output value clipping\n        `pad_with` (int, optional): Padding value for border handling\n\n    Returns:\n        Matrix: Edge-detected image\n\n    Notes\n    -----\n    The Prewitt operator uses two 3\u00d73 kernels to compute horizontal and vertical gradients:\n    Gx = [[-1, 0, 1],     Gy = [[-1, -1, -1],\n          [-1, 0, 1],           [ 0,  0,  0],\n          [-1, 0, 1]]           [ 1,  1,  1]]\n\n    The final magnitude is computed as: sqrt(Gx\u00b2 + Gy\u00b2)\n\n    Examples:\n    &gt;&gt;&gt; img = [[1, 2, 3],\n    ...        [4, 5, 6],\n    ...        [7, 8, 9]]\n    &gt;&gt;&gt; edges = prewitt_operator(img, pad_with=0)\n    &gt;&gt;&gt; # Result highlights vertical and horizontal edges\n    \"\"\"\n    return apply_gradient_operator(matrix, Kernels.prewitt_operator, bit_depth, pad_with)\n</code></pre>"},{"location":"neighborhood_operations/#DIP.neighborhood_operations.prewitt_operator--result-highlights-vertical-and-horizontal-edges","title":"Result highlights vertical and horizontal edges","text":""},{"location":"neighborhood_operations/#DIP.neighborhood_operations.rank_order_filter","title":"<code>rank_order_filter(matrix, kernel_dim, rank, pad_with=None)</code>","text":"<p>Apply rank-order filter on a matrix using a given kernel size and rank.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The original matrix on which the filter is applied.</p> required <code>`kernel_dim`</code> <code>Tuple[int, int]</code> <p>(<code>width</code>, <code>height</code>) The dimensions of the filter kernel.</p> required <code>`rank`</code> <code>int</code> <p>The rank used in the rank-order filter, starts from 1 to the size of the kernel (width * height).</p> required <code>`pad_with`</code> <code>int</code> <p>The value used for padding the matrix. If <code>None</code>, no padding is applied. Defaults to <code>None</code>.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The result of applying the rank-order filter on the matrix.</p> Description <p>This function applies a rank-order filter on the <code>matrix</code> using a filter kernel of specified dimensions (<code>kernel_dim</code>). The <code>rank</code> parameter determines which element in the sorted neighborhood values is selected as the output pixel value.</p> <p>Examples:</p> <p>matrix = [[1, 2, 3], ...           [4, 5, 6], ...           [7, 8, 9]] kernel_dim = (3, 3) rank = 3 result = rank_order_filter(matrix, kernel_dim, rank, pad_with = 0) result [[0, 0, 0] ,[0, 3, 0] ,[0, 0, 0]]</p> Source code in <code>DIP/neighborhood_operations.py</code> Python<pre><code>def rank_order_filter(matrix, kernel_dim:Tuple[int,int], rank:int, pad_with:int|None = None) -&gt; Matrix:\n    \"\"\"\n    Apply rank-order filter on a matrix using a given kernel size and rank.\n\n    Parameters:\n        `matrix` (Matrix): The original matrix on which the filter is applied.\n        `kernel_dim` (Tuple[int,int]): (`width`, `height`) The dimensions of the filter kernel.\n        `rank` (int): The rank used in the rank-order filter, starts from 1 to the size of the kernel (width * height).\n        `pad_with` (int, optional): The value used for padding the matrix. If `None`, no padding is applied. Defaults to `None`.\n\n    Returns:\n        Matrix: The result of applying the rank-order filter on the matrix.\n\n    Description:\n        This function applies a rank-order filter on the `matrix` using a filter kernel of specified dimensions (`kernel_dim`).\n        The `rank` parameter determines which element in the sorted neighborhood values is selected as the output pixel value.\n\n    Examples:\n    &gt;&gt;&gt; matrix = [[1, 2, 3],\n    ...           [4, 5, 6],\n    ...           [7, 8, 9]]\n    &gt;&gt;&gt; kernel_dim = (3, 3)\n    &gt;&gt;&gt; rank = 3\n    &gt;&gt;&gt; result = rank_order_filter(matrix, kernel_dim, rank, pad_with = 0)\n    &gt;&gt;&gt; result\n    [[0, 0, 0]\n    ,[0, 3, 0]\n    ,[0, 0, 0]]\n    \"\"\"\n\n    k_width = kernel_dim[0]\n    k_hieght = kernel_dim[1]\n    if rank &gt; k_width * k_hieght:\n        raise ValueError(\"rank must be less than or equal the number of elements in the filter\")\n\n    output_mat = deepcopy(matrix)\n\n    for neighbors, center in _get_neighborhood_and_center(matrix,(k_width,k_hieght),pad_with=pad_with):\n        # sort the element in the output window\n        sorted_flat_neighbors = [elem for rows in neighbors for elem in rows]\n        sorted_flat_neighbors.sort()\n        # change the pixel in the original image\n        output_mat[center[0]][center[1]] = sorted_flat_neighbors[rank - 1]\n    return output_mat\n</code></pre>"},{"location":"neighborhood_operations/#DIP.neighborhood_operations.roberts_operator","title":"<code>roberts_operator(matrix, bit_depth=None, pad_with=None)</code>","text":"<p>Applies Roberts cross-gradient operator for edge detection.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>Input image as 2D list</p> required <code>`bit_depth`</code> <code>int</code> <p>Bit depth for output value clipping</p> required <code>`pad_with`</code> <code>int</code> <p>Padding value for border handling</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>Edge-detected image</p>"},{"location":"neighborhood_operations/#DIP.neighborhood_operations.roberts_operator--notes","title":"Notes","text":"<p>The Roberts operator uses two 2\u00d72 kernels to compute diagonal gradients: Gx = [[-1, 0],     Gy = [[0, -1],       [0, 1]]           [1, 0]]</p> <p>The final magnitude is computed as: sqrt(Gx\u00b2 + Gy\u00b2)</p> <p>Examples:</p> <p>img = [[1, 2, 3], ...        [4, 5, 6], ...        [7, 8, 9]] edges = roberts_operator(img, pad_with=0)</p> Source code in <code>DIP/neighborhood_operations.py</code> Python<pre><code>def roberts_operator(\n    matrix: Matrix,\n    bit_depth: Optional[int] = None,\n    pad_with: Optional[int] = None\n) -&gt; Matrix:\n    \"\"\"\n    Applies Roberts cross-gradient operator for edge detection.\n\n    Parameters:\n        `matrix` (Matrix): Input image as 2D list\n        `bit_depth` (int, optional): Bit depth for output value clipping\n        `pad_with` (int, optional): Padding value for border handling\n\n    Returns:\n        Matrix: Edge-detected image\n\n    Notes\n    -----\n    The Roberts operator uses two 2\u00d72 kernels to compute diagonal gradients:\n    Gx = [[-1, 0],     Gy = [[0, -1],\n          [0, 1]]           [1, 0]]\n\n    The final magnitude is computed as: sqrt(Gx\u00b2 + Gy\u00b2)\n\n    Examples:\n    &gt;&gt;&gt; img = [[1, 2, 3],\n    ...        [4, 5, 6],\n    ...        [7, 8, 9]]\n    &gt;&gt;&gt; edges = roberts_operator(img, pad_with=0)\n    &gt;&gt;&gt; # Result highlights diagonal edges\n    \"\"\"\n    return apply_gradient_operator(matrix, Kernels.robert_operator, bit_depth, pad_with)\n</code></pre>"},{"location":"neighborhood_operations/#DIP.neighborhood_operations.roberts_operator--result-highlights-diagonal-edges","title":"Result highlights diagonal edges","text":""},{"location":"neighborhood_operations/#DIP.neighborhood_operations.sobel_operator","title":"<code>sobel_operator(matrix, bit_depth=None, pad_with=None)</code>","text":"<p>Applies the Sobel operator for edge detection with enhanced sensitivity.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Matrix</code> <p>Input image as a 2D list.</p> required <code>bit_depth</code> <code>int</code> <p>Bit depth for output value clipping.</p> <code>None</code> <code>pad_with</code> <code>int</code> <p>Padding value for border handling.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>Edge-detected image.</p> Notes <p>The Sobel operator uses two 3\u00d73 kernels to compute horizontal and vertical gradients:</p> <p>Gx = [[-1, 0, 1],     Gy = [[-1, -2, -1],     [-2, 0, 2],           [ 0,  0,  0],     [-1, 0, 1]]           [ 1,  2,  1]]</p> <p>The final magnitude is computed as: sqrt(Gx\u00b2 + Gy\u00b2).</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; img = [[1, 2, 3],\n...        [4, 5, 6],\n...        [7, 8, 9]]\n&gt;&gt;&gt; edges = sobel_operator(img, pad_with=0)\n&gt;&gt;&gt; # Result highlights vertical and horizontal edges.\n</code></pre> Source code in <code>DIP/neighborhood_operations.py</code> Python<pre><code>def sobel_operator(\n    matrix: Matrix,\n    bit_depth: Optional[int] = None,\n    pad_with: Optional[int] = None\n) -&gt; Matrix:\n    \"\"\"\n    Applies the Sobel operator for edge detection with enhanced sensitivity.\n\n    Parameters:\n        matrix (Matrix): Input image as a 2D list.\n        bit_depth (int, optional): Bit depth for output value clipping.\n        pad_with (int, optional): Padding value for border handling.\n\n    Returns:\n        Matrix: Edge-detected image.\n\n    Notes:\n        The Sobel operator uses two 3\u00d73 kernels to compute horizontal and vertical gradients:\n\n        Gx = [[-1, 0, 1],     Gy = [[-1, -2, -1],\n            [-2, 0, 2],           [ 0,  0,  0],\n            [-1, 0, 1]]           [ 1,  2,  1]]\n\n        The final magnitude is computed as: sqrt(Gx\u00b2 + Gy\u00b2).\n\n    Examples:\n        &gt;&gt;&gt; img = [[1, 2, 3],\n        ...        [4, 5, 6],\n        ...        [7, 8, 9]]\n        &gt;&gt;&gt; edges = sobel_operator(img, pad_with=0)\n        &gt;&gt;&gt; # Result highlights vertical and horizontal edges.\n    \"\"\"\n    return apply_gradient_operator(matrix, Kernels.sobel_operator, bit_depth, pad_with)\n</code></pre>"},{"location":"operations/","title":"DIP.operations","text":""},{"location":"operations/#DIP.operations.aggregate_matrices","title":"<code>aggregate_matrices(list_of_matrices, operation, bit_depth=8)</code>","text":"<p>Perform specified operation on a list of matrices representing images.</p> <p>Parameters:</p> Name Type Description Default <code>`list_of_matrices`</code> <code>List[Matrix]</code> <p>List of 2D numpy arrays representing images.</p> required <code>`operation`</code> <code>Literal['diff', 'max', 'min', 'avg']</code> <p>The operation to perform. Valid operations are 'diff', 'max', 'min', and 'avg'.</p> required <code>`bit_depth`</code> <code>int</code> <p>Number of bits used to represent the pixel values (default is 8 for binary).</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>Result of the operation.</p> <p>Examples:</p> <p>matrix1 = [[10 ,20],             [30 ,40]] matrix2 = [[20 ,30],             [5 ,50]] max_result = matrices_min([matrix1,matrix2], operation = 'avg', bit_depth = 4) for row in max_result: ...     print(row) ... [15 ,15] ... [15 ,15]</p> Source code in <code>DIP/operations.py</code> Python<pre><code>def aggregate_matrices(list_of_matrices: List[Matrix], operation: Literal['diff', 'max', 'min', 'avg'], bit_depth: int = 8) -&gt; Matrix:\n    \"\"\"Perform specified operation on a list of matrices representing images.\n\n    Arguments:\n        `list_of_matrices` (List[Matrix]): List of 2D numpy arrays representing images.\n        `operation` (Literal['diff', 'max', 'min', 'avg']): The operation to perform. Valid operations are 'diff', 'max', 'min', and 'avg'.\n        `bit_depth` (int): Number of bits used to represent the pixel values (default is 8 for binary).\n\n    Returns:\n        Matrix: Result of the operation.\n\n    Examples:\n    &gt;&gt;&gt; matrix1 = [[10 ,20],\n                [30 ,40]]\n    &gt;&gt;&gt; matrix2 = [[20 ,30],\n                [5 ,50]]\n    &gt;&gt;&gt; max_result = matrices_min([matrix1,matrix2], operation = 'avg', bit_depth = 4)\n    &gt;&gt;&gt; for row in max_result:\n    ...     print(row)\n    ... [15 ,15]\n    ... [15 ,15]\n    \"\"\"\n    max_value = 2 ** bit_depth - 1\n\n    if operation == 'diff':\n        result = _abs_diff(list_of_matrices[0], list_of_matrices[1])\n    elif operation == 'max':\n        result = _matrices_max(list_of_matrices)\n    elif operation == 'min':\n        result = _matrices_min(list_of_matrices)\n    elif operation == 'avg':\n        result = _matrices_avg(list_of_matrices)\n    # Clip result to ensure it remains within the specified bit depth range\n    result = [[clip(value, 0, max_value) for value in row] for row in result]\n\n    return result\n</code></pre>"},{"location":"operations/#DIP.operations.apply_operations","title":"<code>apply_operations(matrix, operations, values, bit_depth=8)</code>","text":"<p>Apply a series of operations to a matrix.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The input matrix.</p> required <code>`operations`</code> <code>Sequence[Literal['+', '-', '*', '/']]</code> <p>A sequence containing the operations to apply.</p> required <code>`values`</code> <code>Sequence[int]</code> <p>A sequence containing the values for each operation.</p> required <code>`bit_depth`</code> <code>int</code> <p>The bit depth for the operations. Defaults to 8.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The matrix after applying the specified operations.</p> <p>Examples:</p> <p>matrix = [ ...     [100, 200, 50], ...     [150, 75, 225], ...     [25, 175, 125] ... ] operations = ['+', '-', '*', '/'] values = [10, 20, 2, 5] result = apply_operations(matrix, operations, values, bit_depth=8) for row in result: ...     print(row)     [ 36 51 16 ]     [ 51 26 51 ]     [  6 51 46 ]</p> Source code in <code>DIP/operations.py</code> Python<pre><code>def apply_operations(matrix: Matrix,\n                      operations: Sequence[Literal['+', '-', '*', '/']],\n                      values: Sequence[int],\n                      bit_depth: int = 8) -&gt; Matrix:\n    \"\"\"\n    Apply a series of operations to a matrix.\n\n    Parameters:\n        `matrix` (Matrix): The input matrix.\n        `operations` (Sequence[Literal['+', '-', '*', '/']]): A sequence containing the operations to apply.\n        `values` (Sequence[int]): A sequence containing the values for each operation.\n        `bit_depth` (int, optional): The bit depth for the operations. Defaults to 8.\n\n    Returns:\n        Matrix: The matrix after applying the specified operations.\n\n    Examples:\n    &gt;&gt;&gt; matrix = [\n    ...     [100, 200, 50],\n    ...     [150, 75, 225],\n    ...     [25, 175, 125]\n    ... ]\n    &gt;&gt;&gt; operations = ['+', '-', '*', '/']\n    &gt;&gt;&gt; values = [10, 20, 2, 5]\n    &gt;&gt;&gt; result = apply_operations(matrix, operations, values, bit_depth=8)\n    &gt;&gt;&gt; for row in result:\n    ...     print(row)\n        [ 36 51 16 ]\n        [ 51 26 51 ]\n        [  6 51 46 ]\n    \"\"\"\n\n    if len(operations) != len(values):\n        raise ValueError(\"The length of operations and values must be the same\")\n\n    max_value = 2 ** bit_depth - 1\n    result = deepcopy(matrix)\n\n    for op, value in zip(operations, values):\n        if op == '+':\n            result = [[clip(x + value,0,max_value) for x in row] for row in result]\n        elif op == '-':\n            result = [[clip(x - value,0,max_value) for x in row] for row in result]\n        elif op == '*':\n            result = [[clip(x * value,0,max_value) for x in row] for row in result]\n        elif op == '/':\n            if value == 0:\n                raise ValueError(\"Division by zero is not allowed\")\n            result = [[clip(normal_round(x / value),0,max_value) for x in row] for row in result]\n        else:\n            raise ValueError(f\"Unsupported operation: {op}\")\n\n    return result\n</code></pre>"},{"location":"operations/#DIP.operations.complement","title":"<code>complement(matrix, bit_depth=8, threshold=0)</code>","text":"<p>Complement an image and perform solarization if a threshold is given.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The input matrix representing an image.</p> required <code>`bit_depth`</code> <code>int</code> <p>The bit depth of the image. Defaults to 8.</p> required <code>`threshold`</code> <code>int</code> <p>The threshold value for solarization. Defaults to 0.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The complemented and optionally solarized image matrix.</p> <p>Examples:</p> <p>image = [ ...     [100, 200, 50], ...     [150, 75, 225], ...     [25, 175, 125] ... ] complemented_image = complement(image, threshold=100) for row in complemented_image: ...     print(row)     [ 155  55  50 ]     [ 105  75  30 ]     [  25  80 130 ]</p> Source code in <code>DIP/operations.py</code> Python<pre><code>def complement(matrix: Matrix, bit_depth: int=8, threshold: int=0) -&gt; Matrix:\n    \"\"\"\n    Complement an image and perform solarization if a threshold is given.\n\n    Parameters:\n        `matrix` (Matrix): The input matrix representing an image.\n        `bit_depth` (int, optional): The bit depth of the image. Defaults to 8.\n        `threshold` (int, optional): The threshold value for solarization. Defaults to 0.\n\n    Returns:\n        Matrix: The complemented and optionally solarized image matrix.\n\n    Examples:\n    &gt;&gt;&gt; image = [\n    ...     [100, 200, 50],\n    ...     [150, 75, 225],\n    ...     [25, 175, 125]\n    ... ]\n    &gt;&gt;&gt; complemented_image = complement(image, threshold=100)\n    &gt;&gt;&gt; for row in complemented_image:\n    ...     print(row)\n        [ 155  55  50 ]\n        [ 105  75  30 ]\n        [  25  80 130 ]\n    \"\"\"\n    max_value = 2 ** bit_depth - 1\n\n    # Clip the matrix values between 0 and max_value\n    matrix = [[min(max(pixel, 0), max_value) for pixel in row] for row in matrix]\n\n    # Apply complementing and solarization\n    matrix = [[max_value - pixel if pixel &gt;= threshold else pixel for pixel in row] for row in matrix]\n\n    return matrix\n</code></pre>"},{"location":"operations/#DIP.operations.gamma","title":"<code>gamma(matrix, gamma_value=1.0, bit_depth=8)</code>","text":"<p>Apply gamma correction to a matrix.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The input matrix.</p> required <code>`gamma_value`</code> <code>float</code> <p>The gamma value for correction. Defaults to 1.0.</p> required <code>`bit_depth`</code> <code>int</code> <p>The bit depth used to determine the maximum value. Defaults to 8.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The matrix after applying gamma correction.</p> <p>Steps: 1. Determine the maximum possible value (<code>max_value</code>) based on the bit depth. 2. Normalize the pixel values in the matrix to the range [0, 1] by dividing each pixel by <code>max_value</code>. 3. Apply gamma correction to each normalized pixel value by raising it to the power of <code>gamma_value</code>. 4. Multiply the corrected pixel values by <code>max_value</code> and convert them to integers. 5. Clamp the corrected pixel values to ensure they fall within the valid range [0, max_value]. 6. Return the matrix after gamma correction.</p> <p>Examples:</p> <p>matrix = [ ...     [100, 200, 50], ...     [150, 75, 225], ...     [25, 175, 125] ... ] gamma_corrected_matrix = gamma(matrix, gamma_value=1.5, bit_depth=8) for row in gamma_corrected_matrix: ...     print(row)     [  63 177  22 ]     [ 115  41 211 ]     [   8 145  88 ]</p> Source code in <code>DIP/operations.py</code> Python<pre><code>def gamma(matrix: Matrix, gamma_value: float = 1.0, bit_depth: int = 8) -&gt; Matrix:\n    \"\"\"\n    Apply gamma correction to a matrix.\n\n    Parameters:\n        `matrix` (Matrix): The input matrix.\n        `gamma_value` (float, optional): The gamma value for correction. Defaults to 1.0.\n        `bit_depth` (int, optional): The bit depth used to determine the maximum value. Defaults to 8.\n\n    Returns:\n        Matrix: The matrix after applying gamma correction.\n\n    Steps:\n    1. Determine the maximum possible value (`max_value`) based on the bit depth.\n    2. Normalize the pixel values in the matrix to the range [0, 1] by dividing each pixel by `max_value`.\n    3. Apply gamma correction to each normalized pixel value by raising it to the power of `gamma_value`.\n    4. Multiply the corrected pixel values by `max_value` and convert them to integers.\n    5. Clamp the corrected pixel values to ensure they fall within the valid range [0, max_value].\n    6. Return the matrix after gamma correction.\n\n    Examples:\n    &gt;&gt;&gt; matrix = [\n    ...     [100, 200, 50],\n    ...     [150, 75, 225],\n    ...     [25, 175, 125]\n    ... ]\n    &gt;&gt;&gt; gamma_corrected_matrix = gamma(matrix, gamma_value=1.5, bit_depth=8)\n    &gt;&gt;&gt; for row in gamma_corrected_matrix:\n    ...     print(row)\n        [  63 177  22 ]\n        [ 115  41 211 ]\n        [   8 145  88 ]\n    \"\"\"\n    max_value = 2 ** bit_depth - 1\n    # doing the operation on each value then round then clip in one line\n    mat_corrected = [[clip(normal_round(max_value * ((pixel / max_value) ** gamma_value)),0,max_value) for pixel in row] for row in matrix]\n    return mat_corrected\n</code></pre>"},{"location":"operations/#DIP.operations.histogram_equalization","title":"<code>histogram_equalization(matrix, bit_depth=None, show=False)</code>","text":"<p>Perform histogram equalization on a matrix.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The input matrix.</p> required <code>`bit_depth`</code> <code>int</code> <p>The bit depth of the matrix. If not provided, it's determined automatically. Defaults to None.</p> required <code>`show`</code> <code>bool</code> <p>A flag indicating whether to display intermediate values during processing. Defaults to False.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The matrix after histogram equalization.</p> <p>Examples:</p> <p>matrix = [[3,3,1,4,],             [2,3,0,4,],             [2,6,6,3,],             [1,4,0,6,]]</p> <p>equalized_matrix = histogram_equalization(matrix, bit_depth=3, show=True)      R:  0 1 2 3 4 5 6 7 hist_r:  2 2 2 4 3 0 3 0 p(r_k):  0.125 0.125 0.125 0.25 0.188 0.0 0.188 0.0 p(s_k):  0.12 0.25 0.38 0.62 0.81 0.81 1.0 1.0      s:  1 2 3 4 6 6 7 7</p> <p>display_matrices([equalized_matrix],text=[\"Histogram Equalization Result:\"]) ... Histogram Equalization Result: ... [ 4 4 2 6 ] ... [ 3 4 1 6 ] ... [ 3 7 7 4 ] ... [ 2 6 1 7 ]</p> Source code in <code>DIP/operations.py</code> Python<pre><code>def histogram_equalization(matrix: Matrix, bit_depth: int = None, show: bool = False) -&gt; Matrix:\n    \"\"\"\n    Perform histogram equalization on a matrix.\n\n    Parameters:\n        `matrix` (Matrix): The input matrix.\n        `bit_depth` (int, optional): The bit depth of the matrix. If not provided, it's determined automatically. Defaults to None.\n        `show` (bool, optional): A flag indicating whether to display intermediate values during processing. Defaults to False.\n\n    Returns:\n        Matrix: The matrix after histogram equalization.\n\n    Examples:\n    &gt;&gt;&gt; matrix = [[3,3,1,4,],\n                [2,3,0,4,],\n                [2,6,6,3,],\n                [1,4,0,6,]]\n\n    &gt;&gt;&gt; equalized_matrix = histogram_equalization(matrix, bit_depth=3, show=True)\n         R:  0 1 2 3 4 5 6 7\n    hist_r:  2 2 2 4 3 0 3 0\n    p(r_k):  0.125 0.125 0.125 0.25 0.188 0.0 0.188 0.0\n    p(s_k):  0.12 0.25 0.38 0.62 0.81 0.81 1.0 1.0\n         s:  1 2 3 4 6 6 7 7\n\n    &gt;&gt;&gt; display_matrices([equalized_matrix],text=[\"Histogram Equalization Result:\"])\n    ... Histogram Equalization Result:\n    ... [ 4 4 2 6 ]\n    ... [ 3 4 1 6 ]\n    ... [ 3 7 7 4 ]\n    ... [ 2 6 1 7 ]\n    \"\"\"\n    if bit_depth is None:\n        # Determine the bit_depth automatically\n        bit_depth = bit_depth_from_mat(matrix)\n    elif bit_depth &lt;= 0:\n        raise ValueError(\"Bit depth must be positive.\")\n\n    max_value = 2 ** bit_depth - 1\n\n    flat = [pixel for row in matrix for pixel in row]\n    total_pixels = len(flat)\n    # make dict for each value in the range\n    hist = {i: 0 for i in range(max_value + 1)}\n    # calc the freq for each value\n    for pixel in flat:\n        hist[pixel] += 1\n\n    pdf = {key: round(value / total_pixels,3) for key, value in hist.items()}\n    # Calculate cumulative distribution function (CDF)\n    cdf = {}\n    cumulative = 0\n    for key, value in pdf.items():\n        cumulative += value\n        cdf[key] = round( cumulative ,2)\n\n    # For histogram equalization, map each pixel value to its equalized value\n    # based on its cumulative distribution function (CDF)\n    new_values = {key: normal_round(value * max_value) for key,value in cdf.items()}\n\n    if show:\n        print(\"     R: \", *hist.keys())\n        print(\"hist_r: \", *hist.values())\n        print(\"p(r_k): \", *pdf.values())\n        print(\"p(s_k): \", *cdf.values())\n        print(\"     s: \", *new_values.values())\n\n    new_matrix = [[new_values[pixel] for pixel in row] for row in matrix]\n    return new_matrix\n</code></pre>"},{"location":"operations/#DIP.operations.histogram_matching","title":"<code>histogram_matching(matrix, target_histogram, bit_depth=None, show=False)</code>","text":"<p>Perform histogram matching on a matrix.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The input matrix.</p> required <code>`target_histogram`</code> <code>List[float]</code> <p>The target histogram for histogram matching.</p> required <code>`bit_depth`</code> <code>int</code> <p>The bit depth of the matrix. If not provided, it's determined automatically. Defaults to None.</p> required <code>`show`</code> <code>bool</code> <p>A flag indicating whether to display intermediate values during processing. Defaults to False.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The matrix after histogram matching.</p> <p>Description: This function applies histogram matching to the input matrix, matching its histogram to a given target histogram by finding the closest values in the cumulative distribution functions.  It supports optional visualization of intermediate values if <code>show</code> is set to True.</p> <p>Examples:</p> <p>matrix = [[0,4,2,6,4],       [4,2,4,5,6],       [2,4,0,4,6],       [6,6,6,0,6]]</p> <p>target_histogram = [1,0,5,0,6,6,2,5]</p> <p>matched_matrix = histogram_matching(matrix, target_histogram, bit_depth=3, show=True) ...      R:  0 1 2 3 4 5 6 7 ... p(r_k):  0.15 0.0 0.15 0.0 0.3 0.05 0.35 0.0 ... p(s_k):  0.15 0.15 0.3 0.3 0.6 0.65 1.0 1.0 ... p(z_k):  0.04 0.04 0.24 0.24 0.48 0.72 0.8 1.0 ...      s:  2 2 2 2 4 5 7 7</p> <p>display_matrices([matched_matrix],text=[\"Histogram Matching Result:\"]) ... Histogram Matching Result: ... [ 2 4 2 7 4 ] ... [ 4 2 4 5 7 ] ... [ 2 4 2 4 7 ] ... [ 7 7 7 2 7 ]</p> Source code in <code>DIP/operations.py</code> Python<pre><code>def histogram_matching(matrix: Matrix,\n                       target_histogram: List[float],\n                       bit_depth: int = None,\n                       show: bool = False) -&gt; Matrix:\n    \"\"\"\n    Perform histogram matching on a matrix.\n\n    Parameters:\n        `matrix` (Matrix): The input matrix.\n        `target_histogram` (List[float]): The target histogram for histogram matching.\n        `bit_depth` (int, optional): The bit depth of the matrix. If not provided, it's determined automatically. Defaults to None.\n        `show` (bool, optional): A flag indicating whether to display intermediate values during processing. Defaults to False.\n\n    Returns:\n        Matrix: The matrix after histogram matching.\n\n    Description:\n    This function applies histogram matching to the input matrix, matching its histogram to a given target histogram by finding the closest values in the cumulative distribution functions. \n    It supports optional visualization of intermediate values if `show` is set to True.\n\n    Examples:\n    &gt;&gt;&gt; matrix = [[0,4,2,6,4],\n          [4,2,4,5,6],\n          [2,4,0,4,6],\n          [6,6,6,0,6]]\n\n    &gt;&gt;&gt; target_histogram = [1,0,5,0,6,6,2,5]\n\n    &gt;&gt;&gt; matched_matrix = histogram_matching(matrix, target_histogram, bit_depth=3, show=True)\n    ...      R:  0 1 2 3 4 5 6 7\n    ... p(r_k):  0.15 0.0 0.15 0.0 0.3 0.05 0.35 0.0\n    ... p(s_k):  0.15 0.15 0.3 0.3 0.6 0.65 1.0 1.0\n    ... p(z_k):  0.04 0.04 0.24 0.24 0.48 0.72 0.8 1.0\n    ...      s:  2 2 2 2 4 5 7 7\n\n    &gt;&gt;&gt; display_matrices([matched_matrix],text=[\"Histogram Matching Result:\"])\n    ... Histogram Matching Result:\n    ... [ 2 4 2 7 4 ]\n    ... [ 4 2 4 5 7 ]\n    ... [ 2 4 2 4 7 ]\n    ... [ 7 7 7 2 7 ]\n    \"\"\"\n    if bit_depth is None:\n        # Determine the bit_depth automatically\n        bit_depth = bit_depth_from_mat(matrix)\n    elif bit_depth &lt;= 0:\n        raise ValueError(\"Bit depth must be positive.\")\n\n    max_value = 2 ** bit_depth - 1\n\n    if target_histogram is None:\n        raise ValueError(\"Target histogram is required for histogram matching.\")\n    if len(range(max_value + 1)) != len(target_histogram):\n        raise ValueError(\"Target histogram must be same range of values of matrix.\")\n\n    flat = [pixel for row in matrix for pixel in row]\n    # make dict for each value in the range\n    hist = {i: 0 for i in range(max_value + 1)}\n    # calc the freq for each value\n    for pixel in flat:\n        hist[pixel] += 1\n\n    def _calculate_cdf(hist: Dict[int, int]) -&gt; Tuple[Dict[int, int],Dict[int, float]]:\n        # the total may diff from hist to another\n        total_pixels = sum(hist.values())\n        pdf = {key: round(value / total_pixels,3) for key, value in hist.items()}\n        # Calculate cumulative distribution function (CDF)\n        cdf = {}\n        cumulative = 0\n        for key, value in pdf.items():\n            cumulative += value\n            cdf[key] = round( cumulative ,2)\n        return cdf,pdf\n\n    cdf,pdf = _calculate_cdf(hist)\n\n    # For histogram matching, calculate the target cumulative distribution function (CDF)\n    # from the given target histogram and map each pixel value to the closest value\n    # in the target CDF\n\n    # make target hist key value pairs since we are taking values only\n    target_hist = {i: freq for i, freq in enumerate(target_histogram)}\n    # Calculate the target cumulative distribution function (CDF)\n    target_cdf, _ = _calculate_cdf(target_hist)\n    new_values = {}\n    for key,value in cdf.items():\n        # Find the closest key in the target CDF to match the CDF of the original pixel value\n        diff = float('inf')\n        closest_key = None\n        for target_key,target_value in target_cdf.items():\n            if abs(value - target_value) &lt; diff:\n                diff = abs(value - target_value)\n                closest_key = target_key\n        new_values[key] = closest_key\n\n    if show:\n        # Calculate the maximum length of elements in the matrix\n        max_length = max(len(str(number)) for number in pdf.values())\n        R = \" \".join((str(number)).ljust(max_length) for number in hist.keys())\n\n        print(\"     R: \", R)\n        print(\"p(r_k): \", *pdf.values())\n        print(\"p(s_k): \", *cdf.values())\n        print(\"p(z_k): \", *target_cdf.values())\n        print(\"     s: \", *new_values.values())\n\n    new_matrix = [[new_values[pixel] for pixel in row] for row in matrix]\n    return new_matrix\n</code></pre>"},{"location":"operations/#DIP.operations.histogram_stretch","title":"<code>histogram_stretch(matrix, bit_depth=8)</code>","text":"<p>Perform histogram stretching on a matrix.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The input matrix.</p> required <code>`bit_depth`</code> <code>int</code> <p>The bit depth used to determine the maximum value. Defaults to 8.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The matrix after histogram stretching.</p> <p>Examples:</p> <p>matrix = [ ...     [100, 200, 50], ...     [150, 75, 225], ...     [25, 175, 125] ... ] stretched_matrix = histogram_stretch(matrix, bit_depth=8) for row in stretched_matrix: ...     print(row)     [  96 223  32 ]     [ 159  64 255 ]     [   0 191 127 ]</p> Source code in <code>DIP/operations.py</code> Python<pre><code>def histogram_stretch(matrix: Matrix, bit_depth: int = 8) -&gt; Matrix:\n    \"\"\"\n    Perform histogram stretching on a matrix.\n\n    Parameters:\n        `matrix` (Matrix): The input matrix.\n        `bit_depth` (int, optional): The bit depth used to determine the maximum value. Defaults to 8.\n\n    Returns:\n        Matrix: The matrix after histogram stretching.\n\n    Examples:\n    &gt;&gt;&gt; matrix = [\n    ...     [100, 200, 50],\n    ...     [150, 75, 225],\n    ...     [25, 175, 125]\n    ... ]\n    &gt;&gt;&gt; stretched_matrix = histogram_stretch(matrix, bit_depth=8)\n    &gt;&gt;&gt; for row in stretched_matrix:\n    ...     print(row)\n        [  96 223  32 ]\n        [ 159  64 255 ]\n        [   0 191 127 ]\n    \"\"\"\n\n    min_val = min(min(row) for row in matrix)\n    max_val = max(max(row) for row in matrix)\n    range_val = max_val - min_val\n    max_pixel_value = 2 ** bit_depth - 1\n    # doing the stretching then round\n    stretched = [[normal_round((pixel - min_val) * (max_pixel_value / range_val)) for pixel in row] for row in matrix]\n    return stretched\n</code></pre>"},{"location":"operations/#DIP.operations.mat_logical_operate","title":"<code>mat_logical_operate(matrix1, matrix2, operation, bit_depth=8)</code>","text":"<p>Perform logical operations on two matrices.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix1`</code> <code>Matrix</code> <p>The first matrix.</p> required <code>`matrix2`</code> <code>Matrix</code> <p>The second matrix.</p> required <code>`operation`</code> <code>Literal['AND', 'OR', 'XOR']</code> <p>The logical operation to perform. Supported operations are 'AND', 'OR', and 'XOR'.</p> required <p>Examples:</p> <p>matrix1 = [ ...     [1, 0, 1], ...     [0, 1, 0], ...     [1, 1, 1] ... ] matrix2 = [ ...     [1, 1, 0], ...     [0, 0, 1], ...     [1, 0, 1] ... ] result = logical_operations(matrix1, matrix2, 'AND') for row in result: ...     print(row) ... [1, 0, 0] ... [0, 0, 0] ... [1, 0, 1]</p> Source code in <code>DIP/operations.py</code> Python<pre><code>def mat_logical_operate(matrix1: Matrix, matrix2: Matrix,\n                        operation: Literal['AND', 'OR', 'XOR'],\n                          bit_depth: int = 8) -&gt; Matrix:\n    \"\"\"\n    Perform logical operations on two matrices.\n\n    Parameters:\n        `matrix1` (Matrix): The first matrix.\n        `matrix2` (Matrix): The second matrix.\n        `operation` (Literal['AND', 'OR', 'XOR']): The logical operation to perform. Supported operations are 'AND', 'OR', and 'XOR'.\n\n    Examples:\n    &gt;&gt;&gt; matrix1 = [\n    ...     [1, 0, 1],\n    ...     [0, 1, 0],\n    ...     [1, 1, 1]\n    ... ]\n    &gt;&gt;&gt; matrix2 = [\n    ...     [1, 1, 0],\n    ...     [0, 0, 1],\n    ...     [1, 0, 1]\n    ... ]\n    &gt;&gt;&gt; result = logical_operations(matrix1, matrix2, 'AND')\n    &gt;&gt;&gt; for row in result:\n    ...     print(row)\n    ... [1, 0, 0]\n    ... [0, 0, 0]\n    ... [1, 0, 1]\n    \"\"\"\n    max_value = 2 ** bit_depth - 1\n    rows, cols = len(matrix1), len(matrix1[0])\n    result = [[0 for _ in range(cols)] for _ in range(rows)]\n    operations = {'AND':lambda x, y : x&amp;y,\n                  'OR':lambda x, y : x|y,\n                  'XOR':lambda x, y : x^y}\n    for i in range(rows):\n        for j in range(cols):\n            result[i][j] = clip(operations[operation](matrix1[i][j],matrix2[i][j]), 0, max_value)\n    return result\n</code></pre>"},{"location":"operations/#DIP.operations.mat_operate","title":"<code>mat_operate(list_of_matrices, operation, bit_depth=8)</code>","text":"<p>Performs a specified arithmetic operation on a list of matrices.</p> <p>Parameters:</p> Name Type Description Default <code>`list_of_matrices`</code> <code>List[Matrix]</code> <p>A list of matrices on which to perform the operation.</p> required <code>`operation`</code> <code>Literal['+', '-', '*', '/']</code> <p>The arithmetic operation to perform. Supported operations are addition ('+'), subtraction ('-'), multiplication ('*'), and division ('/').</p> required <code>`bit_depth`</code> <code>int</code> <p>The bit depth for clamping result values. Defaults to 8.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>The resulting matrix after performing the specified operation.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; matrix1 = [\n...     [1, 2, 3],\n...     [4, 5, 6],\n...     [7, 8, 9]\n... ]\n&gt;&gt;&gt; matrix2 = [\n...     [9, 8, 7],\n...     [6, 5, 4],\n...     [3, 2, 1]\n... ]\n&gt;&gt;&gt; result = basic_operations([matrix1, matrix2], '+')\n&gt;&gt;&gt; for row in result:\n...     print(row)\n[10, 10, 10]\n[10, 10, 10]\n[10, 10, 10]\n</code></pre> Source code in <code>DIP/operations.py</code> Python<pre><code>def mat_operate(list_of_matrices: List[Matrix],\n                      operation: Literal['+', '-', '*', '/'],\n                        bit_depth: int = 8) -&gt; Matrix:\n    \"\"\"\n    Performs a specified arithmetic operation on a list of matrices.\n\n    Parameters:\n        `list_of_matrices` (List[Matrix]): A list of matrices on which to perform the operation.\n        `operation` (Literal['+', '-', '*', '/']): The arithmetic operation to perform. Supported operations are addition ('+'), subtraction ('-'), multiplication ('*'), and division ('/').\n        `bit_depth` (int, optional): The bit depth for clamping result values. Defaults to 8.\n\n    Returns:\n        Matrix: The resulting matrix after performing the specified operation.\n\n    Examples:\n        &gt;&gt;&gt; matrix1 = [\n        ...     [1, 2, 3],\n        ...     [4, 5, 6],\n        ...     [7, 8, 9]\n        ... ]\n        &gt;&gt;&gt; matrix2 = [\n        ...     [9, 8, 7],\n        ...     [6, 5, 4],\n        ...     [3, 2, 1]\n        ... ]\n        &gt;&gt;&gt; result = basic_operations([matrix1, matrix2], '+')\n        &gt;&gt;&gt; for row in result:\n        ...     print(row)\n        [10, 10, 10]\n        [10, 10, 10]\n        [10, 10, 10]\n    \"\"\"\n\n    if not list_of_matrices:\n        return []\n    max_value = 2 ** bit_depth - 1\n    result = deepcopy(list_of_matrices[0])\n\n    operations = {'+':lambda x, y : x+y,\n                  '-':lambda x, y : x-y,\n                  '*':lambda x, y : x*y,\n                  \"/\":lambda x, y : normal_round(x/y) if y != 0 else 0}\n\n    for matrix in list_of_matrices[1:]:\n        for i,_ in enumerate(result):\n            for j in range(len(result[0])):\n                result[i][j] = clip(operations[operation](result[i][j],matrix[i][j]),0,max_value)\n    return result\n</code></pre>"},{"location":"plugins/","title":"Plugins","text":""},{"location":"plugins/#plot_morphology","title":"<code>plot_morphology</code>","text":"<p>Description: <code>plot_morphology</code> is a utility function for visualizing grayscale morphological images with several customizable options, including grid overlays, pixel value display, and axis numbering. It allows fine-tuning of figure scaling, making it adaptable to various visualization needs.</p> <p>Function Signature:</p> Python<pre><code>def plot_morphology(images: List[Matrix], titles: List[str],\n                    draw_border=True, show_numbers=False,\n                    show_axis=False, figure_scale=0.7):\n</code></pre> <p>Parameters:</p> <ul> <li> <p><code>images</code> (list of matrices):      A list of 2D arrays representing grayscale images. Each array is displayed as a separate subplot.</p> </li> <li> <p><code>titles</code> (list of str):      Titles corresponding to each image, appearing above each subplot.</p> </li> <li> <p><code>draw_border</code> (bool, default=True):      If <code>True</code>, draws a border grid around each pixel for clearer pixel boundary inspection.</p> </li> <li> <p><code>show_numbers</code> (bool, default=False):      If <code>True</code>, displays the value of each pixel inside its cell, useful for exact pixel inspection.</p> </li> <li> <p><code>show_axis</code> (bool, default=False):      If <code>True</code>, shows numbering on the x and y axes, which aids in locating specific pixel positions.</p> </li> <li> <p><code>figure_scale</code> (float, default=0.7):      A scale factor for adjusting the overall figure size. Valid values range from 0 to 1. Higher values increase the plot size.</p> </li> </ul> <p>Usage Example:</p> Python<pre><code>from DIP.morphology import hit_or_miss\n\nbit_dipth = 4\n\nim = [[0,0,0,0,0,0,0,0],\n      [0,0,0,1,1,0,0,0],\n      [0,0,1,1,1,1,0,0],\n      [0,1,1,1,1,1,1,0],\n      [0,1,1,1,1,1,1,0],\n      [0,0,1,1,1,1,0,0],\n      [0,0,0,1,1,0,0,0],\n      [0,0,0,0,0,0,0,0]]\n\nse1 = [[0,1,0],\n      [1,1,0],\n      [0,1,0]]\n\nse2 = [[1,0,0],\n      [0,0,0],\n      [1,0,0]]\n\nresult = hit_or_miss(im, se1, se2)\n\nplot_morphology([im, se1, se2, result], ['Image', 'SE1', 'SE2', 'Hit or Miss'],\n                draw_border=True, show_numbers=True, show_axis=True, figure_scale=0.5)\n</code></pre> <p></p> <p>Notes:</p> <ul> <li>The function applies a <code>gray_r</code> colormap, mapping <code>0</code> to white and <code>1</code> to black.</li> <li>If only a single image is provided, it\u2019s wrapped in a list to ensure compatibility.</li> <li>For better performance with large images, consider setting <code>draw_border=False</code> or adjusting <code>figure_scale</code>.</li> </ul> <p>Dependencies: you need to install <code>matplotlib</code> to use this plugin</p> Bash<pre><code>python -m pip install matplotlib==3.9.0\n</code></pre> <p>Returns: This function does not return a value; it directly displays the plot using <code>plt.show()</code>.</p>"},{"location":"segmentation/","title":"DIP.segmentation","text":""},{"location":"segmentation/#DIP.segmentation.automatic_threshold","title":"<code>automatic_threshold(matrix, threshold=0.2, bit_depth=1, max_iterations=10, show_steps=False)</code>","text":"<p>Apply automatic thresholding to a matrix using the specified algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The input matrix.</p> required <code>`threshold`</code> <code>float</code> <p>The convergence threshold for the algorithm. Defaults to 0.2.</p> required <code>`max_iterations`</code> <code>int</code> <p>The maximum number of iterations allowed. Defaults to 10.</p> required <code>`show`</code> <code>bool</code> <p>A flag indicating whether to display the intermediate threshold values during iterations. Defaults to False.</p> required <p>Returns:</p> Type Description <code>Matrix</code> <p><code>Matrix</code>: The matrix after applying automatic thresholding.</p> <p>Steps: 1. Initialize the old threshold (<code>theta_old</code>) with the mean value of the matrix. 2. Calculate the mean values of pixels below and above the threshold (<code>mu_1</code> and <code>mu_2</code>). 3. Compute the new threshold (<code>theta_new</code>) as the average of <code>mu_1</code> and <code>mu_2</code>. 4. Check for convergence: if the absolute difference between <code>theta_new</code> and <code>theta_old</code> is less than or equal to the threshold, or the maximum number of iterations is reached, exit the loop. 5. Update <code>theta_old</code> with <code>theta_new</code>. 6. Increment the iteration count. 7. Apply the final threshold to the matrix: set pixels with values greater than the threshold to 255 (white) and others to 0 (black).</p> <p>Examples:</p> <p>matrix = [ ...     [100, 200, 50], ...     [150, 75, 225], ...     [25, 175, 125] ... ] thresholded_matrix = automatic_threshold(matrix, threshold=0.2, max_iterations=10, show=True)     theta_0: 125.000     theta_1: 131.250 for row in thresholded_matrix: ...     print(row)     [   0 255   0 ]     [ 255   0 255 ]     [   0 255   0 ]</p> Source code in <code>DIP/segmentation.py</code> Python<pre><code>def automatic_threshold(matrix: Matrix, threshold: float = 0.2, bit_depth:int = 1, max_iterations: int = 10, show_steps: bool = False) -&gt; Matrix:\n    \"\"\"\n    Apply automatic thresholding to a matrix using the specified algorithm.\n\n    Parameters:\n        `matrix` (Matrix): The input matrix.\n        `threshold` (float, optional): The convergence threshold for the algorithm. Defaults to 0.2.\n        `max_iterations` (int, optional): The maximum number of iterations allowed. Defaults to 10.\n        `show` (bool, optional): A flag indicating whether to display the intermediate threshold values during iterations. Defaults to False.\n\n    Returns:\n        `Matrix`: The matrix after applying automatic thresholding.\n\n    Steps:\n    1. Initialize the old threshold (`theta_old`) with the mean value of the matrix.\n    2. Calculate the mean values of pixels below and above the threshold (`mu_1` and `mu_2`).\n    3. Compute the new threshold (`theta_new`) as the average of `mu_1` and `mu_2`.\n    4. Check for convergence: if the absolute difference between `theta_new` and `theta_old` is less than or equal to the threshold, or the maximum number of iterations is reached, exit the loop.\n    5. Update `theta_old` with `theta_new`.\n    6. Increment the iteration count.\n    7. Apply the final threshold to the matrix: set pixels with values greater than the threshold to 255 (white) and others to 0 (black).\n\n\n    Examples:\n    &gt;&gt;&gt; matrix = [\n    ...     [100, 200, 50],\n    ...     [150, 75, 225],\n    ...     [25, 175, 125]\n    ... ]\n    &gt;&gt;&gt; thresholded_matrix = automatic_threshold(matrix, threshold=0.2, max_iterations=10, show=True)\n        theta_0: 125.000\n        theta_1: 131.250\n    &gt;&gt;&gt; for row in thresholded_matrix:\n    ...     print(row)\n        [   0 255   0 ]\n        [ 255   0 255 ]\n        [   0 255   0 ]\n    \"\"\"\n\n    max_value = 2 ** bit_depth - 1\n\n    def mean(matrix: Matrix) -&gt; float:\n        count = len(matrix)*len(matrix[0])\n        total = sum(sum(row) for row in matrix)\n        return total / count\n\n    def mean_below(matrix: Matrix, threshold_value: float) -&gt; float:\n        values = [pixel for row in matrix for pixel in row if pixel &lt;= threshold_value]\n        return sum(values) / len(values) if values else 0\n\n    def mean_above(matrix: Matrix, threshold_value: float) -&gt; float:\n        values = [pixel for row in matrix for pixel in row if pixel &gt; threshold_value]\n        return sum(values) / len(values) if values else 0\n\n    theta_old = mean(matrix)\n    iteration = 0\n    if show_steps:\n        print(f'theta_{iteration}: {theta_old:0.3f}')\n    while True:\n        mu_1 = mean_below(matrix, theta_old)\n        mu_2 = mean_above(matrix, theta_old)\n        theta_new = (mu_1 + mu_2) / 2\n\n        if abs(theta_new - theta_old) &lt;= threshold or iteration &gt;= max_iterations:\n            break\n\n        theta_old = theta_new\n        iteration += 1\n        if show_steps:\n            print(f'theta_{iteration}: {theta_new:.3f}')\n\n    return [[max_value if pixel &gt; theta_new else 0 for pixel in row] for row in matrix]\n</code></pre>"},{"location":"segmentation/#DIP.segmentation.binarizarion","title":"<code>binarizarion(matrix, threshold=None, bit_depth=1)</code>","text":"<p>Apply basic thresholding to an image.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>Input image matrix</p> required <code>`threshold`</code> <code>int</code> <p>Threshold value (if None, uses mean of matrix)</p> required <code>`bit_depth`</code> <code>int</code> <p>Output bit depth</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>Binary matrix where values above threshold are max_value, others are 0</p> Source code in <code>DIP/segmentation.py</code> Python<pre><code>def binarizarion(matrix: Matrix, threshold: Optional[int] = None, bit_depth:int = 1) -&gt; Matrix:\n    \"\"\"\n    Apply basic thresholding to an image.\n\n    Parameters:\n        `matrix` (Matrix): Input image matrix\n        `threshold` (int, optional): Threshold value (if None, uses mean of matrix)\n        `bit_depth` (int): Output bit depth\n\n    Returns:\n        Matrix: Binary matrix where values above threshold are max_value, others are 0\n    \"\"\"\n    max_value = 2 ** bit_depth - 1\n\n    if threshold is None:\n        threshold = sum(elem for rows in matrix for elem in rows)/(len(matrix) * len(matrix[0]))\n\n    return [[max_value if pixel &gt; threshold else 0 for pixel in row] for row in matrix]\n</code></pre>"},{"location":"segmentation/#DIP.segmentation.double_threshold","title":"<code>double_threshold(matrix, lower_threshold=85, upper_threshold=170, bit_depth=8)</code>","text":"<p>Applies dual thresholding to an image matrix, producing a binary output matrix.  Pixel values within the threshold range are set to the maximum value based on  the specified bit depth, while others are set to zero.</p> <p>Parameters:</p> Name Type Description Default <code>`matrix`</code> <code>Matrix</code> <p>The input image matrix to process.</p> required <code>`lower_threshold`</code> <code>int</code> <p>Lower boundary for thresholding.</p> required <code>`upper_threshold`</code> <code>int</code> <p>Upper boundary for thresholding.</p> required <code>`bit_depth`</code> <code>int</code> <p>Bit depth to determine max output value.</p> required <p>Returns:</p> Name Type Description <code>Matrix</code> <code>Matrix</code> <p>A binary matrix where pixel values between thresholds are set to      <code>max_value</code> (based on <code>bit_depth</code>), and others are set to 0.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>lower_threshold</code> is not less than <code>upper_threshold</code>.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; img = [[100, 120, 180],\n...        [60, 85, 200],\n...        [90, 150, 160]]\n&gt;&gt;&gt; processed_img = double_threshold(img, lower_threshold=85, upper_threshold=170, bit_depth=8)\n&gt;&gt;&gt; # Result will highlight values in the 85-170 range.\n</code></pre> Source code in <code>DIP/segmentation.py</code> Python<pre><code>def double_threshold(\n    matrix: Matrix, \n    lower_threshold: int = 85, \n    upper_threshold: int = 170, \n    bit_depth: int = 8\n) -&gt; Matrix:\n    \"\"\"\n    Applies dual thresholding to an image matrix, producing a binary output matrix. \n    Pixel values within the threshold range are set to the maximum value based on \n    the specified bit depth, while others are set to zero.\n\n    Parameters:\n        `matrix` (Matrix): The input image matrix to process.\n        `lower_threshold` (int, optional): Lower boundary for thresholding.\n        `upper_threshold` (int, optional): Upper boundary for thresholding.\n        `bit_depth` (int, optional): Bit depth to determine max output value.\n\n    Returns:\n        Matrix: A binary matrix where pixel values between thresholds are set to \n                `max_value` (based on `bit_depth`), and others are set to 0.\n\n    Raises:\n        ValueError: If `lower_threshold` is not less than `upper_threshold`.\n\n    Examples:\n        &gt;&gt;&gt; img = [[100, 120, 180],\n        ...        [60, 85, 200],\n        ...        [90, 150, 160]]\n        &gt;&gt;&gt; processed_img = double_threshold(img, lower_threshold=85, upper_threshold=170, bit_depth=8)\n        &gt;&gt;&gt; # Result will highlight values in the 85-170 range.\n    \"\"\"\n    if not 0 &lt;= lower_threshold &lt; upper_threshold:\n        raise ValueError(\"Lower threshold must be less than upper threshold\")\n\n    max_value = 2 ** bit_depth - 1\n\n    return [\n        [max_value if lower_threshold &lt; pixel &lt; upper_threshold else 0\n          for pixel in row]\n            for row in matrix\n        ]\n</code></pre>"}]}